import{aY as Z,aZ as $,aV as j,av as x,aq as T,aW as z,b3 as J}from"./BalBtn-a3a093af.js";import{s as B,a as X,L as y}from"./user-data.provider-5f113b17.js";import{c as q,W as ee,a8 as U,U as ae,Z as re,o as te}from"./connector-d867b6ec.js";import{v as W,q as s,ah as oe,r as se}from"./runtime-core.esm-bundler-24a2b16f.js";import{i as h}from"./useQueryHelpers-8fe10019.js";function ue(t,r={}){const i=W(Z.Pool.Gauges(t)),c=s(()=>!!(t!=null&&t.value)),u=s(()=>{var o,v;return{__name:"PoolGauges",pool:{__args:{id:(o=t.value)==null?void 0:o.toLowerCase()},preferentialGauge:{id:!0},gauges:{id:!0,relativeWeightCap:!0}},liquidityGauges:{__args:{where:{poolAddress:(v=t.value)==null?void 0:v.toLowerCase()}},id:!0}}}),f=async()=>{try{return await B({url:q.network.subgraphs.gauge,query:u.value})}catch(o){throw console.error(`Failed to fetch pool gauge for pool: ${t.value}`,{cause:o}),o}},n=W({enabled:c,refetchOnWindowFocus:!1,...r});return $(i,f,n)}const ne=t=>{const r=se(t),i=s(()=>r.value?ee(r.value):void 0),{balanceFor:c}=x(),{account:u,isWalletReady:f}=T(),n=ue(i),{data:o,refetch:v}=n,{userGaugeSharesQuery:w,userBoostsQuery:S,stakedSharesQuery:b}=X(),{data:d,refetch:Q}=w,{data:G,refetch:_}=S,{data:p,refetch:m,isRefetching:E}=b,C=s(()=>h(n)||f.value&&(h(b)||h(w)||h(S))),g=s(()=>{var e,a,l;return(l=(a=(e=o.value)==null?void 0:e.pool)==null?void 0:a.preferentialGauge)==null?void 0:l.id}),F=s(()=>{var e,a,l;return!!r.value&&((l=(a=(e=o.value)==null?void 0:e.liquidityGauges)==null?void 0:a[0])==null?void 0:l.id)!==void 0&&U.Stakable.VotingGaugePools.concat(U.Stakable.AllowList).includes(r.value)}),I=s(()=>{var e;return r.value&&((e=p==null?void 0:p.value)==null?void 0:e[r.value])||"0"}),R=s(()=>!G.value||!r.value?"1":G[r.value]),O=s(()=>{var e;return((e=o.value)==null?void 0:e.pool.gauges.map(a=>a.id))||[]}),K=s(()=>d.value?d.value.reduce((e,a)=>(e[a.gauge.id]=a.balance,e),{}):{}),N=s(()=>{if(!o.value||!d.value||!g.value)return!1;const e=g.value;return O.value.some(a=>!ae(a,e)&&re(K.value[a]||"0").gt(0))});function Y(e){r.value=e}async function A(){return Promise.all([v(),m(),Q(),_()])}async function D(){if(!i.value)throw new Error("No pool to stake.");if(!g.value)throw new Error(`No preferential gauge found for this pool: ${r.value}`);const e=new y(g.value),a=J(c(te(i.value)));return await e.stake(a)}async function H(){var k,P;if(!((P=(k=o.value)==null?void 0:k.pool)!=null&&P.gauges))throw new Error("Unable to unstake, no pool gauges");const a=(await le(o.value,u.value))[0],l=new y(a.id),V=await l.balance(u.value);return await l.unstake(V)}async function M(e){try{return(await B({url:q.network.subgraphs.gauge,query:{pool:{__args:{id:e.toLowerCase()},preferentialGauge:{id:!0}}}})).pool.preferentialGauge.id}catch(a){throw console.error(a),a}}return{isLoading:C,stakedShares:I,isStakablePool:F,boost:R,hasNonPrefGaugeBalance:N,isRefetchingStakedShares:E,refetchStakedShares:m,preferentialGaugeAddress:g,fetchPreferentialGaugeAddress:M,setCurrentPool:Y,refetchAllPoolStakingData:A,stake:D,unstake:H,poolGauges:o}},L=Symbol(z.Providers.PoolStaking);function he(t){oe(L,ne(t))}function de(){return j(L)}async function le(t,r){const c=(await Promise.all(t.pool.gauges.map(async u=>{const n=await new y(u.id).balance(r);return{...u,balance:n==null?void 0:n.toString()}}))).filter(u=>u.balance!=="0");if(c.length===0)throw new Error("User doesn't have any balance for any gauges.");return c}export{he as p,de as u};
//# sourceMappingURL=pool-staking.provider-7a0c7e0f.js.map
