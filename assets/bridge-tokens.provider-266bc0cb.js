var ji=Object.defineProperty;var Gi=(r,e,t)=>e in r?ji(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var _t=(r,e,t)=>(Gi(r,typeof e!="symbol"?e+"":e,t),t);import{t as br,_ as ee,c as Tr,u as Vi,S as hs,V as Zi,o as Ft,W as ps,X as yn,O as Yi,i as Xi,Z as Ji,U as gs}from"./connector-d867b6ec.js";import{aS as Qi,aY as ea,aZ as ta,aV as na,ax as ra,aq as sa,aW as oa}from"./BalBtn-a3a093af.js";import{s as ia}from"./readable-browser-744f1df3.js";import{B as xe}from"./browser-6a4b4883.js";import{g as to,c as st,a as no}from"./_commonjsHelpers-87174ba5.js";import{v as ro,r as aa}from"./useTransactions-19512b92.js";import{q as nt,v as wr,r as so,ah as ca,am as ua,ai as la}from"./runtime-core.esm-bundler-24a2b16f.js";function ys(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`Wrong positive integer: ${r}`)}function fa(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function oo(r,...e){if(!fa(r))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(r.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${r.length}`)}function da(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ys(r.outputLen),ys(r.blockLen)}function kn(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function ha(r,e){oo(r);const t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const tr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function io(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}const nr=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),tt=(r,e)=>r<<32-e|r>>>e,pa=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!pa)throw new Error("Non little-endian hardware is not supported");function ao(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function Lr(r){if(typeof r=="string"&&(r=ao(r)),!io(r))throw new Error(`expected Uint8Array, got ${typeof r}`);return r}function co(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];if(!io(s))throw new Error("Uint8Array expected");e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}class uo{clone(){return this._cloneInto()}}function lo(r){const e=n=>r().update(Lr(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function fo(r=32){if(tr&&typeof tr.getRandomValues=="function")return tr.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}function ga(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=n?4:0,u=n?0:4;r.setUint32(e+c,i,n),r.setUint32(e+u,a,n)}class ho extends uo{constructor(e,t,n,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=nr(this.buffer)}update(e){kn(this);const{view:t,buffer:n,blockLen:s}=this;e=Lr(e);const o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=nr(e);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){kn(this),ha(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(n,0),i=0);for(let d=i;d<s;d++)t[d]=0;ga(n,s-8,BigInt(this.length*8),o),this.process(n,0);const a=nr(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)a.setUint32(4*d,l[d],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return e.length=s,e.pos=a,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(n),e}}const bn=BigInt(2**32-1),mr=BigInt(32);function po(r,e=!1){return e?{h:Number(r&bn),l:Number(r>>mr&bn)}:{h:Number(r>>mr&bn)|0,l:Number(r&bn)|0}}function ya(r,e=!1){let t=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let s=0;s<r.length;s++){const{h:o,l:i}=po(r[s],e);[t[s],n[s]]=[o,i]}return[t,n]}const ba=(r,e)=>BigInt(r>>>0)<<mr|BigInt(e>>>0),wa=(r,e,t)=>r>>>t,ma=(r,e,t)=>r<<32-t|e>>>t,va=(r,e,t)=>r>>>t|e<<32-t,Sa=(r,e,t)=>r<<32-t|e>>>t,xa=(r,e,t)=>r<<64-t|e>>>t-32,ka=(r,e,t)=>r>>>t-32|e<<64-t,Ea=(r,e)=>e,_a=(r,e)=>r,Ba=(r,e,t)=>r<<t|e>>>32-t,Aa=(r,e,t)=>e<<t|r>>>32-t,Ia=(r,e,t)=>e<<t-32|r>>>64-t,Ra=(r,e,t)=>r<<t-32|e>>>64-t;function Ta(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const La=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),Ca=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Pa=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Oa=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Ua=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Na=(r,e,t,n,s,o)=>e+t+n+s+o+(r/2**32|0)|0,qa={fromBig:po,split:ya,toBig:ba,shrSH:wa,shrSL:ma,rotrSH:va,rotrSL:Sa,rotrBH:xa,rotrBL:ka,rotr32H:Ea,rotr32L:_a,rotlSH:Ba,rotlSL:Aa,rotlBH:Ia,rotlBL:Ra,add:Ta,add3L:La,add3H:Ca,add4L:Pa,add4H:Oa,add5H:Na,add5L:Ua},te=qa,[Fa,za]=(()=>te.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))))(),yt=new Uint32Array(80),bt=new Uint32Array(80);class Da extends ho{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:d,Fl:k,Gh:m,Gl:y,Hh:f,Hl:p}=this;return[e,t,n,s,o,i,a,c,u,l,d,k,m,y,f,p]}set(e,t,n,s,o,i,a,c,u,l,d,k,m,y,f,p){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=d|0,this.Fl=k|0,this.Gh=m|0,this.Gl=y|0,this.Hh=f|0,this.Hl=p|0}process(e,t){for(let x=0;x<16;x++,t+=4)yt[x]=e.getUint32(t),bt[x]=e.getUint32(t+=4);for(let x=16;x<80;x++){const _=yt[x-15]|0,I=bt[x-15]|0,v=te.rotrSH(_,I,1)^te.rotrSH(_,I,8)^te.shrSH(_,I,7),R=te.rotrSL(_,I,1)^te.rotrSL(_,I,8)^te.shrSL(_,I,7),A=yt[x-2]|0,M=bt[x-2]|0,j=te.rotrSH(A,M,19)^te.rotrBH(A,M,61)^te.shrSH(A,M,6),V=te.rotrSL(A,M,19)^te.rotrBL(A,M,61)^te.shrSL(A,M,6),ie=te.add4L(R,V,bt[x-7],bt[x-16]),ae=te.add4H(ie,v,j,yt[x-7],yt[x-16]);yt[x]=ae|0,bt[x]=ie|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:d,El:k,Fh:m,Fl:y,Gh:f,Gl:p,Hh:S,Hl:B}=this;for(let x=0;x<80;x++){const _=te.rotrSH(d,k,14)^te.rotrSH(d,k,18)^te.rotrBH(d,k,41),I=te.rotrSL(d,k,14)^te.rotrSL(d,k,18)^te.rotrBL(d,k,41),v=d&m^~d&f,R=k&y^~k&p,A=te.add5L(B,I,R,za[x],bt[x]),M=te.add5H(A,S,_,v,Fa[x],yt[x]),j=A|0,V=te.rotrSH(n,s,28)^te.rotrBH(n,s,34)^te.rotrBH(n,s,39),ie=te.rotrSL(n,s,28)^te.rotrBL(n,s,34)^te.rotrBL(n,s,39),ae=n&o^n&a^o&a,Q=s&i^s&c^i&c;S=f|0,B=p|0,f=m|0,p=y|0,m=d|0,y=k|0,{h:d,l:k}=te.add(u|0,l|0,M|0,j|0),u=a|0,l=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const P=te.add3L(j,ie,Q);n=te.add3H(P,M,V,ae),s=P|0}({h:n,l:s}=te.add(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=te.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=te.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=te.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:d,l:k}=te.add(this.Eh|0,this.El|0,d|0,k|0),{h:m,l:y}=te.add(this.Fh|0,this.Fl|0,m|0,y|0),{h:f,l:p}=te.add(this.Gh|0,this.Gl|0,f|0,p|0),{h:S,l:B}=te.add(this.Hh|0,this.Hl|0,S|0,B|0),this.set(n,s,o,i,a,c,u,l,d,k,m,y,f,p,S,B)}roundClean(){yt.fill(0),bt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const go=lo(()=>new Da);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yo=BigInt(0),Wn=BigInt(1),Ma=BigInt(2);function ot(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}const Ka=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function Ct(r){if(!ot(r))throw new Error("Uint8Array expected");let e="";for(let t=0;t<r.length;t++)e+=Ka[r[t]];return e}function bo(r){const e=r.toString(16);return e.length&1?`0${e}`:e}function Cr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}const lt={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function bs(r){if(r>=lt._0&&r<=lt._9)return r-lt._0;if(r>=lt._A&&r<=lt._F)return r-(lt._A-10);if(r>=lt._a&&r<=lt._f)return r-(lt._a-10)}function $t(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const e=r.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,o=0;s<t;s++,o+=2){const i=bs(r.charCodeAt(o)),a=bs(r.charCodeAt(o+1));if(i===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function Tt(r){return Cr(Ct(r))}function Ht(r){if(!ot(r))throw new Error("Uint8Array expected");return Cr(Ct(Uint8Array.from(r).reverse()))}function jt(r,e){return $t(r.toString(16).padStart(e*2,"0"))}function rn(r,e){return jt(r,e).reverse()}function Ha(r){return $t(bo(r))}function ke(r,e,t){let n;if(typeof e=="string")try{n=$t(e)}catch(o){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${o}`)}else if(ot(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(`${r} expected ${t} bytes, got ${s}`);return n}function Pt(...r){let e=0;for(let s=0;s<r.length;s++){const o=r[s];if(!ot(o))throw new Error("Uint8Array expected");e+=o.length}let t=new Uint8Array(e),n=0;for(let s=0;s<r.length;s++){const o=r[s];t.set(o,n),n+=o.length}return t}function Wa(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function $a(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function ja(r){let e;for(e=0;r>yo;r>>=Wn,e+=1);return e}function Ga(r,e){return r>>BigInt(e)&Wn}const Va=(r,e,t)=>r|(t?Wn:yo)<<BigInt(e),Pr=r=>(Ma<<BigInt(r-1))-Wn,rr=r=>new Uint8Array(r),ws=r=>Uint8Array.from(r);function wo(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=rr(r),s=rr(r),o=0;const i=()=>{n.fill(1),s.fill(0),o=0},a=(...d)=>t(s,n,...d),c=(d=rr())=>{s=a(ws([0]),d),n=a(),d.length!==0&&(s=a(ws([1]),d),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const k=[];for(;d<e;){n=a();const m=n.slice();k.push(m),d+=n.length}return Pt(...k)};return(d,k)=>{i(),c(d);let m;for(;!(m=k(u()));)c();return i(),m}}const Za={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ot(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Zt(r,e,t={}){const n=(s,o,i)=>{const a=Za[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=r[s];if(!(i&&c===void 0)&&!a(c,r))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(e))n(s,o,!1);for(const[s,o]of Object.entries(t))n(s,o,!0);return r}const Ya=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Ga,bitLen:ja,bitMask:Pr,bitSet:Va,bytesToHex:Ct,bytesToNumberBE:Tt,bytesToNumberLE:Ht,concatBytes:Pt,createHmacDrbg:wo,ensureBytes:ke,equalBytes:Wa,hexToBytes:$t,hexToNumber:Cr,isBytes:ot,numberToBytesBE:jt,numberToBytesLE:rn,numberToHexUnpadded:bo,numberToVarBytesBE:Ha,utf8ToBytes:$a,validateObject:Zt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _e=BigInt(0),be=BigInt(1),Bt=BigInt(2),Xa=BigInt(3),vr=BigInt(4),ms=BigInt(5),vs=BigInt(8);BigInt(9);BigInt(16);function ge(r,e){const t=r%e;return t>=_e?t:e+t}function Ja(r,e,t){if(t<=_e||e<_e)throw new Error("Expected power/modulo > 0");if(t===be)return _e;let n=be;for(;e>_e;)e&be&&(n=n*r%t),r=r*r%t,e>>=be;return n}function we(r,e,t){let n=r;for(;e-- >_e;)n*=n,n%=t;return n}function Sr(r,e){if(r===_e||e<=_e)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=ge(r,e),n=e,s=_e,o=be;for(;t!==_e;){const a=n/t,c=n%t,u=s-o*a;n=t,t=c,s=o,o=u}if(n!==be)throw new Error("invert: does not exist");return ge(s,e)}function Qa(r){const e=(r-be)/Bt;let t,n,s;for(t=r-be,n=0;t%Bt===_e;t/=Bt,n++);for(s=Bt;s<r&&Ja(s,e,r)!==r-be;s++);if(n===1){const i=(r+be)/vr;return function(c,u){const l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}const o=(t+be)/Bt;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=n,l=a.pow(a.mul(a.ONE,s),t),d=a.pow(c,o),k=a.pow(c,t);for(;!a.eql(k,a.ONE);){if(a.eql(k,a.ZERO))return a.ZERO;let m=1;for(let f=a.sqr(k);m<u&&!a.eql(f,a.ONE);m++)f=a.sqr(f);const y=a.pow(l,be<<BigInt(u-m-1));l=a.sqr(y),d=a.mul(d,y),k=a.mul(k,l),u=m}return d}}function ec(r){if(r%vr===Xa){const e=(r+be)/vr;return function(n,s){const o=n.pow(s,e);if(!n.eql(n.sqr(o),s))throw new Error("Cannot find square root");return o}}if(r%vs===ms){const e=(r-ms)/vs;return function(n,s){const o=n.mul(s,Bt),i=n.pow(o,e),a=n.mul(s,i),c=n.mul(n.mul(a,Bt),i),u=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),s))throw new Error("Cannot find square root");return u}}return Qa(r)}const tc=(r,e)=>(ge(r,e)&be)===be,nc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function rc(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=nc.reduce((n,s)=>(n[s]="function",n),e);return Zt(r,t)}function sc(r,e,t){if(t<_e)throw new Error("Expected power > 0");if(t===_e)return r.ONE;if(t===be)return e;let n=r.ONE,s=e;for(;t>_e;)t&be&&(n=r.mul(n,s)),s=r.sqr(s),t>>=be;return n}function oc(r,e){const t=new Array(e.length),n=e.reduce((o,i,a)=>r.is0(i)?o:(t[a]=o,r.mul(o,i)),r.ONE),s=r.inv(n);return e.reduceRight((o,i,a)=>r.is0(i)?o:(t[a]=r.mul(o,t[a]),r.mul(o,i)),s),t}function mo(r,e){const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function vo(r,e,t=!1,n={}){if(r<=_e)throw new Error(`Expected Field ORDER > 0, got ${r}`);const{nBitLength:s,nByteLength:o}=mo(r,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=ec(r),a=Object.freeze({ORDER:r,BITS:s,BYTES:o,MASK:Pr(s),ZERO:_e,ONE:be,create:c=>ge(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return _e<=c&&c<r},is0:c=>c===_e,isOdd:c=>(c&be)===be,neg:c=>ge(-c,r),eql:(c,u)=>c===u,sqr:c=>ge(c*c,r),add:(c,u)=>ge(c+u,r),sub:(c,u)=>ge(c-u,r),mul:(c,u)=>ge(c*u,r),pow:(c,u)=>sc(a,c,u),div:(c,u)=>ge(c*Sr(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>Sr(c,r),sqrt:n.sqrt||(c=>i(a,c)),invertBatch:c=>oc(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>t?rn(c,o):jt(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return t?Ht(c):Tt(c)}});return Object.freeze(a)}function ic(r,e){if(!r.isOdd)throw new Error("Field doesn't have isOdd");const t=r.sqrt(e);return r.isOdd(t)?r.neg(t):t}function So(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function xo(r){const e=So(r);return e+Math.ceil(e/2)}function ac(r,e,t=!1){const n=r.length,s=So(e),o=xo(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const i=t?Tt(r):Ht(r),a=ge(i,e-be)+be;return t?rn(a,s):jt(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const cc=BigInt(0),sr=BigInt(1);function ko(r,e){const t=(s,o)=>{const i=o.negate();return s?i:o},n=s=>{const o=Math.ceil(e/s)+1,i=2**(s-1);return{windows:o,windowSize:i}};return{constTimeNegate:t,unsafeLadder(s,o){let i=r.ZERO,a=s;for(;o>cc;)o&sr&&(i=i.add(a)),a=a.double(),o>>=sr;return i},precomputeWindow(s,o){const{windows:i,windowSize:a}=n(o),c=[];let u=s,l=u;for(let d=0;d<i;d++){l=u,c.push(l);for(let k=1;k<a;k++)l=l.add(u),c.push(l);u=l.double()}return c},wNAF(s,o,i){const{windows:a,windowSize:c}=n(s);let u=r.ZERO,l=r.BASE;const d=BigInt(2**s-1),k=2**s,m=BigInt(s);for(let y=0;y<a;y++){const f=y*c;let p=Number(i&d);i>>=m,p>c&&(p-=k,i+=sr);const S=f,B=f+Math.abs(p)-1,x=y%2!==0,_=p<0;p===0?l=l.add(t(x,o[S])):u=u.add(t(_,o[B]))}return{p:u,f:l}},wNAFCached(s,o,i,a){const c=s._WINDOW_SIZE||1;let u=o.get(s);return u||(u=this.precomputeWindow(s,c),c!==1&&o.set(s,a(u))),this.wNAF(c,u,i)}}}function Or(r){return rc(r.Fp),Zt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...mo(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xe=BigInt(0),De=BigInt(1),wn=BigInt(2),uc=BigInt(8),lc={zip215:!0};function fc(r){const e=Or(r);return Zt(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Ur(r){const e=fc(r),{Fp:t,n,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,u=wn<<BigInt(a*8)-De,l=t.create,d=e.uvRatio||((C,h)=>{try{return{isValid:!0,value:t.sqrt(C*t.inv(h))}}catch{return{isValid:!1,value:Xe}}}),k=e.adjustScalarBytes||(C=>C),m=e.domain||((C,h,g)=>{if(h.length||g)throw new Error("Contexts/pre-hash are not supported");return C}),y=C=>typeof C=="bigint"&&Xe<C,f=(C,h)=>y(C)&&y(h)&&C<h,p=C=>C===Xe||f(C,u);function S(C,h){if(f(C,h))return C;throw new Error(`Expected valid scalar < ${h}, got ${typeof C} ${C}`)}function B(C){return C===Xe?C:S(C,n)}const x=new Map;function _(C){if(!(C instanceof I))throw new Error("ExtendedPoint expected")}class I{constructor(h,g,E,L){if(this.ex=h,this.ey=g,this.ez=E,this.et=L,!p(h))throw new Error("x required");if(!p(g))throw new Error("y required");if(!p(E))throw new Error("z required");if(!p(L))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(h){if(h instanceof I)throw new Error("extended point not allowed");const{x:g,y:E}=h||{};if(!p(g)||!p(E))throw new Error("invalid affine point");return new I(g,E,De,l(g*E))}static normalizeZ(h){const g=t.invertBatch(h.map(E=>E.ez));return h.map((E,L)=>E.toAffine(g[L])).map(I.fromAffine)}_setWindowSize(h){this._WINDOW_SIZE=h,x.delete(this)}assertValidity(){const{a:h,d:g}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:E,ey:L,ez:U,et:O}=this,Z=l(E*E),Y=l(L*L),J=l(U*U),le=l(J*J),ce=l(Z*h),de=l(J*l(ce+Y)),Be=l(le+l(g*l(Z*Y)));if(de!==Be)throw new Error("bad point: equation left != right (1)");const Ne=l(E*L),ve=l(U*O);if(Ne!==ve)throw new Error("bad point: equation left != right (2)")}equals(h){_(h);const{ex:g,ey:E,ez:L}=this,{ex:U,ey:O,ez:Z}=h,Y=l(g*Z),J=l(U*L),le=l(E*Z),ce=l(O*L);return Y===J&&le===ce}is0(){return this.equals(I.ZERO)}negate(){return new I(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:h}=e,{ex:g,ey:E,ez:L}=this,U=l(g*g),O=l(E*E),Z=l(wn*l(L*L)),Y=l(h*U),J=g+E,le=l(l(J*J)-U-O),ce=Y+O,de=ce-Z,Be=Y-O,Ne=l(le*de),ve=l(ce*Be),Ye=l(le*Be),Et=l(de*ce);return new I(Ne,ve,Et,Ye)}add(h){_(h);const{a:g,d:E}=e,{ex:L,ey:U,ez:O,et:Z}=this,{ex:Y,ey:J,ez:le,et:ce}=h;if(g===BigInt(-1)){const is=l((U-L)*(J+Y)),as=l((U+L)*(J-Y)),er=l(as-is);if(er===Xe)return this.double();const cs=l(O*wn*ce),us=l(Z*wn*le),ls=us+cs,fs=as+is,ds=us-cs,Ki=l(ls*er),Hi=l(fs*ds),Wi=l(ls*ds),$i=l(er*fs);return new I(Ki,Hi,$i,Wi)}const de=l(L*Y),Be=l(U*J),Ne=l(Z*E*ce),ve=l(O*le),Ye=l((L+U)*(Y+J)-de-Be),Et=ve-Ne,Qt=ve+Ne,os=l(Be-g*de),Fi=l(Ye*Et),zi=l(Qt*os),Di=l(Ye*os),Mi=l(Et*Qt);return new I(Fi,zi,Mi,Di)}subtract(h){return this.add(h.negate())}wNAF(h){return A.wNAFCached(this,x,h,I.normalizeZ)}multiply(h){const{p:g,f:E}=this.wNAF(S(h,n));return I.normalizeZ([g,E])[0]}multiplyUnsafe(h){let g=B(h);return g===Xe?R:this.equals(R)||g===De?this:this.equals(v)?this.wNAF(g).p:A.unsafeLadder(this,g)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return A.unsafeLadder(this,n).is0()}toAffine(h){const{ex:g,ey:E,ez:L}=this,U=this.is0();h==null&&(h=U?uc:t.inv(L));const O=l(g*h),Z=l(E*h),Y=l(L*h);if(U)return{x:Xe,y:De};if(Y!==De)throw new Error("invZ was invalid");return{x:O,y:Z}}clearCofactor(){const{h}=e;return h===De?this:this.multiplyUnsafe(h)}static fromHex(h,g=!1){const{d:E,a:L}=e,U=t.BYTES;h=ke("pointHex",h,U);const O=h.slice(),Z=h[U-1];O[U-1]=Z&-129;const Y=Ht(O);Y===Xe||(g?S(Y,u):S(Y,t.ORDER));const J=l(Y*Y),le=l(J-De),ce=l(E*J-L);let{isValid:de,value:Be}=d(le,ce);if(!de)throw new Error("Point.fromHex: invalid y coordinate");const Ne=(Be&De)===De,ve=(Z&128)!==0;if(!g&&Be===Xe&&ve)throw new Error("Point.fromHex: x=0 and x_0=1");return ve!==Ne&&(Be=l(-Be)),I.fromAffine({x:Be,y:Y})}static fromPrivateKey(h){return V(h).point}toRawBytes(){const{x:h,y:g}=this.toAffine(),E=rn(g,t.BYTES);return E[E.length-1]|=h&De?128:0,E}toHex(){return Ct(this.toRawBytes())}}I.BASE=new I(e.Gx,e.Gy,De,l(e.Gx*e.Gy)),I.ZERO=new I(Xe,De,De,Xe);const{BASE:v,ZERO:R}=I,A=ko(I,a*8);function M(C){return ge(C,n)}function j(C){return M(Ht(C))}function V(C){const h=a;C=ke("private key",C,h);const g=ke("hashed private key",o(C),2*h),E=k(g.slice(0,h)),L=g.slice(h,2*h),U=j(E),O=v.multiply(U),Z=O.toRawBytes();return{head:E,prefix:L,scalar:U,point:O,pointBytes:Z}}function ie(C){return V(C).pointBytes}function ae(C=new Uint8Array,...h){const g=Pt(...h);return j(o(m(g,ke("context",C),!!s)))}function Q(C,h,g={}){C=ke("message",C),s&&(C=s(C));const{prefix:E,scalar:L,pointBytes:U}=V(h),O=ae(g.context,E,C),Z=v.multiply(O).toRawBytes(),Y=ae(g.context,Z,U,C),J=M(O+Y*L);B(J);const le=Pt(Z,rn(J,t.BYTES));return ke("result",le,a*2)}const P=lc;function N(C,h,g,E=P){const{context:L,zip215:U}=E,O=t.BYTES;C=ke("signature",C,2*O),h=ke("message",h),s&&(h=s(h));const Z=Ht(C.slice(O,2*O));let Y,J,le;try{Y=I.fromHex(g,U),J=I.fromHex(C.slice(0,O),U),le=v.multiplyUnsafe(Z)}catch{return!1}if(!U&&Y.isSmallOrder())return!1;const ce=ae(L,J.toRawBytes(),Y.toRawBytes(),h);return J.add(Y.multiplyUnsafe(ce)).subtract(le).clearCofactor().equals(I.ZERO)}return v._setWindowSize(8),{CURVE:e,getPublicKey:ie,sign:Q,verify:N,ExtendedPoint:I,utils:{getExtendedPublicKey:V,randomPrivateKey:()=>i(t.BYTES),precompute(C=8,h=I.BASE){return h._setWindowSize(C),h.multiply(BigInt(3)),h}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Nr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Ss=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const dc=BigInt(1),xr=BigInt(2),hc=BigInt(5),xs=BigInt(10),pc=BigInt(20),gc=BigInt(40),ks=BigInt(80);function yc(r){const e=Nr,n=r*r%e*r%e,s=we(n,xr,e)*n%e,o=we(s,dc,e)*r%e,i=we(o,hc,e)*o%e,a=we(i,xs,e)*i%e,c=we(a,pc,e)*a%e,u=we(c,gc,e)*c%e,l=we(u,ks,e)*u%e,d=we(l,ks,e)*u%e,k=we(d,xs,e)*i%e;return{pow_p_5_8:we(k,xr,e)*r%e,b2:n}}function bc(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function wc(r,e){const t=Nr,n=ge(e*e*e,t),s=ge(n*n*e,t),o=yc(r*s).pow_p_5_8;let i=ge(r*n*o,t);const a=ge(e*i*i,t),c=i,u=ge(i*Ss,t),l=a===r,d=a===ge(-r,t),k=a===ge(-r*Ss,t);return l&&(i=c),(d||k)&&(i=u),tc(i,t)&&(i=ge(-i,t)),{isValid:l||d,value:i}}const pt=vo(Nr,void 0,!0),qr={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:pt,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:go,randomBytes:fo,adjustScalarBytes:bc,uvRatio:wc},ln=Ur(qr);function Eo(r,e,t){if(e.length>255)throw new Error("Context is too big");return co(ao("SigEd25519 no Ed25519 collisions"),new Uint8Array([t?1:0,e.length]),e,r)}({...qr});({...qr});const mc=(pt.ORDER+BigInt(3))/BigInt(8);pt.pow(xr,mc);pt.sqrt(pt.neg(pt.ONE));(pt.ORDER-BigInt(5))/BigInt(8);BigInt(486662);ic(pt,pt.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var mn=ia.Buffer;function vc(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<r.length;n++){var s=r.charAt(n),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=n}var i=r.length,a=r.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(m){if((Array.isArray(m)||m instanceof Uint8Array)&&(m=mn.from(m)),!mn.isBuffer(m))throw new TypeError("Expected Buffer");if(m.length===0)return"";for(var y=0,f=0,p=0,S=m.length;p!==S&&m[p]===0;)p++,y++;for(var B=(S-p)*u+1>>>0,x=new Uint8Array(B);p!==S;){for(var _=m[p],I=0,v=B-1;(_!==0||I<f)&&v!==-1;v--,I++)_+=256*x[v]>>>0,x[v]=_%i>>>0,_=_/i>>>0;if(_!==0)throw new Error("Non-zero carry");f=I,p++}for(var R=B-f;R!==B&&x[R]===0;)R++;for(var A=a.repeat(y);R<B;++R)A+=r.charAt(x[R]);return A}function d(m){if(typeof m!="string")throw new TypeError("Expected String");if(m.length===0)return mn.alloc(0);for(var y=0,f=0,p=0;m[y]===a;)f++,y++;for(var S=(m.length-y)*c+1>>>0,B=new Uint8Array(S);m[y];){var x=e[m.charCodeAt(y)];if(x===255)return;for(var _=0,I=S-1;(x!==0||_<p)&&I!==-1;I--,_++)x+=i*B[I]>>>0,B[I]=x%256>>>0,x=x/256>>>0;if(x!==0)throw new Error("Non-zero carry");p=_,y++}for(var v=S-p;v!==S&&B[v]===0;)v++;var R=mn.allocUnsafe(f+(S-v));R.fill(0,0,f);for(var A=f;v!==S;)R[A++]=B[v++];return R}function k(m){var y=d(m);if(y)return y;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:d,decode:k}}var Sc=vc,xc=Sc,kc="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Ee=xc(kc);const Ec=(r,e,t)=>r&e^~r&t,_c=(r,e,t)=>r&e^r&t^e&t,Bc=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),wt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),mt=new Uint32Array(64);class Ac extends ho{constructor(){super(64,32,8,!1),this.A=wt[0]|0,this.B=wt[1]|0,this.C=wt[2]|0,this.D=wt[3]|0,this.E=wt[4]|0,this.F=wt[5]|0,this.G=wt[6]|0,this.H=wt[7]|0}get(){const{A:e,B:t,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,n,s,o,i,a,c]}set(e,t,n,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)mt[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const k=mt[d-15],m=mt[d-2],y=tt(k,7)^tt(k,18)^k>>>3,f=tt(m,17)^tt(m,19)^m>>>10;mt[d]=f+mt[d-7]+y+mt[d-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let d=0;d<64;d++){const k=tt(a,6)^tt(a,11)^tt(a,25),m=l+k+Ec(a,c,u)+Bc[d]+mt[d]|0,f=(tt(n,2)^tt(n,13)^tt(n,22))+_c(n,s,o)|0;l=u,u=c,c=a,a=i+m|0,i=o,o=s,s=n,n=m+f|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,a,c,u,l)}roundClean(){mt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const kr=lo(()=>new Ac);var Te={};function ft(r,e,t){return e<=r&&r<=t}function $n(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function Ic(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function Rc(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var En=-1;function Fr(r){this.tokens=[].slice.call(r)}Fr.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():En},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var Gt=-1;function or(r,e){if(r)throw TypeError("Decoder error");return e||65533}var _n="utf-8";function Bn(r,e){if(!(this instanceof Bn))return new Bn(r,e);if(r=r!==void 0?String(r).toLowerCase():_n,r!==_n)throw new Error("Encoding not supported. Only utf-8 is supported");e=$n(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=Boolean(e.fatal),this._ignoreBOM=Boolean(e.ignoreBOM),Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}Bn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=$n(t),this._streaming||(this._decoder=new Tc({fatal:this._fatal}),this._BOMseen=!1),this._streaming=Boolean(t.stream);for(var s=new Fr(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==Gt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===Gt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),Rc(o)}};function An(r,e){if(!(this instanceof An))return new An(r,e);if(r=r!==void 0?String(r).toLowerCase():_n,r!==_n)throw new Error("Encoding not supported. Only utf-8 is supported");e=$n(e),this._streaming=!1,this._encoder=null,this._options={fatal:Boolean(e.fatal)},Object.defineProperty(this,"encoding",{value:"utf-8"})}An.prototype={encode:function(e,t){e=e?String(e):"",t=$n(t),this._streaming||(this._encoder=new Lc(this._options)),this._streaming=Boolean(t.stream);for(var n=[],s=new Fr(Ic(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==Gt);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==Gt;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function Tc(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===En&&s!==0)return s=0,or(e);if(c===En)return Gt;if(s===0){if(ft(c,0,127))return c;if(ft(c,194,223))s=1,t=c-192;else if(ft(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(ft(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return or(e);return t=t<<6*s,null}if(!ft(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),or(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var u=t;return t=s=n=0,u}}function Lc(r){r.fatal,this.handler=function(e,t){if(t===En)return Gt;if(ft(t,0,127))return t;var n,s;ft(t,128,2047)?(n=1,s=192):ft(t,2048,65535)?(n=2,s=224):ft(t,65536,1114111)&&(n=3,s=240);for(var o=[(t>>6*n)+s];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const Cc=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:Bn,TextEncoder:An},Symbol.toStringTag,{value:"Module"})),Pc=to(Cc);var Oc=st&&st.__createBinding||(Object.create?function(r,e,t,n){n===void 0&&(n=t),Object.defineProperty(r,n,{enumerable:!0,get:function(){return e[t]}})}:function(r,e,t,n){n===void 0&&(n=t),r[n]=e[t]}),Uc=st&&st.__setModuleDefault||(Object.create?function(r,e){Object.defineProperty(r,"default",{enumerable:!0,value:e})}:function(r,e){r.default=e}),at=st&&st.__decorate||function(r,e,t,n){var s=arguments.length,o=s<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(i=r[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},Nc=st&&st.__importStar||function(r){if(r&&r.__esModule)return r;var e={};if(r!=null)for(var t in r)t!=="default"&&Object.hasOwnProperty.call(r,t)&&Oc(e,r,t);return Uc(e,r),e},_o=st&&st.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(Te,"__esModule",{value:!0});var Bo=Te.deserializeUnchecked=Co=Te.deserialize=Lo=Te.serialize=Te.BinaryReader=Te.BinaryWriter=Te.BorshError=Te.baseDecode=Te.baseEncode=void 0;const St=_o(br),Ao=_o(Ee),qc=Nc(Pc),Fc=typeof TextDecoder!="function"?qc.TextDecoder:TextDecoder,zc=new Fc("utf-8",{fatal:!0});function Dc(r){return typeof r=="string"&&(r=xe.from(r,"utf8")),Ao.default.encode(xe.from(r))}Te.baseEncode=Dc;function Mc(r){return xe.from(Ao.default.decode(r))}Te.baseDecode=Mc;const ir=1024;class qe extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Te.BorshError=qe;class Io{constructor(){this.buf=xe.alloc(ir),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=xe.concat([this.buf,xe.alloc(ir)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(xe.from(new St.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(xe.from(new St.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(xe.from(new St.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(xe.from(new St.default(e).toArray("le",64)))}writeBuffer(e){this.buf=xe.concat([xe.from(this.buf.subarray(0,this.length)),e,xe.alloc(ir)]),this.length+=e.length}writeString(e){this.maybeResize();const t=xe.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(xe.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}Te.BinaryWriter=Io;function ct(r,e,t){const n=t.value;t.value=function(...s){try{return n.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new qe("Reached the end of buffer when deserializing")}throw o}}}class We{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new St.default(e,"le")}readU128(){const e=this.readBuffer(16);return new St.default(e,"le")}readU256(){const e=this.readBuffer(32);return new St.default(e,"le")}readU512(){const e=this.readBuffer(64);return new St.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new qe(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return zc.decode(t)}catch(n){throw new qe(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let s=0;s<t;++s)n.push(e());return n}}at([ct],We.prototype,"readU8",null);at([ct],We.prototype,"readU16",null);at([ct],We.prototype,"readU32",null);at([ct],We.prototype,"readU64",null);at([ct],We.prototype,"readU128",null);at([ct],We.prototype,"readU256",null);at([ct],We.prototype,"readU512",null);at([ct],We.prototype,"readString",null);at([ct],We.prototype,"readFixedArray",null);at([ct],We.prototype,"readArray",null);Te.BinaryReader=We;function Ro(r){return r.charAt(0).toUpperCase()+r.slice(1)}function At(r,e,t,n,s){try{if(typeof n=="string")s[`write${Ro(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new qe(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new qe(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)At(r,null,t[o],n[0],s)}else s.writeArray(t,o=>{At(r,e,o,n[0],s)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),At(r,e,t,n.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{At(r,e,i,n.key,s),At(r,e,o,n.value,s)});break}default:throw new qe(`FieldType ${n} unrecognized`)}else To(r,t,s)}catch(o){throw o instanceof qe&&o.addToFieldPath(e),o}}function To(r,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=r.get(e.constructor);if(!n)throw new qe(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([s,o])=>{At(r,s,e[s],o,t)});else if(n.kind==="enum"){const s=e[n.field];for(let o=0;o<n.values.length;++o){const[i,a]=n.values[o];if(i===s){t.writeU8(o),At(r,i,e[i],a,t);break}}}else throw new qe(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Kc(r,e,t=Io){const n=new t;return To(r,e,n),n.toArray()}var Lo=Te.serialize=Kc;function It(r,e,t,n){try{if(typeof t=="string")return n[`read${Ro(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(It(r,null,t[0],n));return s}else return n.readArray(()=>It(r,e,t[0],n))}if(t.kind==="option")return n.readU8()?It(r,e,t.type,n):void 0;if(t.kind==="map"){let s=new Map;const o=n.readU32();for(let i=0;i<o;i++){const a=It(r,e,t.key,n),c=It(r,e,t.value,n);s.set(a,c)}return s}return zr(r,t,n)}catch(s){throw s instanceof qe&&s.addToFieldPath(e),s}}function zr(r,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=r.get(e);if(!n)throw new qe(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const s={};for(const[o,i]of r.get(e).fields)s[o]=It(r,o,i,t);return new e(s)}if(n.kind==="enum"){const s=t.readU8();if(s>=n.values.length)throw new qe(`Enum index: ${s} is out of range`);const[o,i]=n.values[s],a=It(r,o,i,t);return new e({[o]:a})}throw new qe(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Hc(r,e,t,n=We){const s=new n(t),o=zr(r,e,s);if(s.offset<t.length)throw new qe(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var Co=Te.deserialize=Hc;function Wc(r,e,t,n=We){const s=new n(t);return zr(r,e,s)}Bo=Te.deserializeUnchecked=Wc;var w={};Object.defineProperty(w,"__esModule",{value:!0});w.s16=w.s8=w.nu64be=w.u48be=w.u40be=w.u32be=w.u24be=w.u16be=Ie=w.nu64=w.u48=w.u40=G=w.u32=w.u24=Ve=w.u16=se=w.u8=Lt=w.offset=w.greedy=w.Constant=w.UTF8=w.CString=w.Blob=w.Boolean=w.BitField=w.BitStructure=w.VariantLayout=w.Union=w.UnionLayoutDiscriminator=w.UnionDiscriminator=w.Structure=w.Sequence=w.DoubleBE=w.Double=w.FloatBE=w.Float=w.NearInt64BE=w.NearInt64=w.NearUInt64BE=w.NearUInt64=w.IntBE=w.Int=w.UIntBE=w.UInt=w.OffsetLayout=w.GreedyCount=w.ExternalLayout=w.bindConstructorLayout=w.nameWithProperty=w.Layout=w.uint8ArrayToBuffer=w.checkUint8Array=void 0;w.constant=w.utf8=w.cstr=fe=w.blob=w.unionLayoutDiscriminator=w.union=Ue=w.seq=w.bits=K=w.struct=w.f64be=w.f64=w.f32be=w.f32=w.ns64be=w.s48be=w.s40be=w.s32be=w.s24be=w.s16be=Me=w.ns64=w.s48=w.s40=w.s32=w.s24=void 0;const Dr=ee;function Yt(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}w.checkUint8Array=Yt;function oe(r){return Yt(r),Dr.Buffer.from(r.buffer,r.byteOffset,r.length)}w.uint8ArrayToBuffer=oe;class ue{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}w.Layout=ue;function Mr(r,e){return e.property?r+"["+e.property+"]":r}w.nameWithProperty=Mr;function $c(r,e){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof ue))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=e,e.boundConstructor_=r,e.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(r,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}w.bindConstructorLayout=$c;class Fe extends ue{isCount(){throw new Error("ExternalLayout is abstract")}}w.ExternalLayout=Fe;class Po extends Fe{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Yt(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}w.GreedyCount=Po;class Kr extends Fe{constructor(e,t=0,n){if(!(e instanceof ue))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof Ze||this.layout instanceof Qe}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}w.OffsetLayout=Kr;class Ze extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readUIntLE(t,this.span)}encode(e,t,n=0){return oe(t).writeUIntLE(e,n,this.span),this.span}}w.UInt=Ze;class Qe extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readUIntBE(t,this.span)}encode(e,t,n=0){return oe(t).writeUIntBE(e,n,this.span),this.span}}w.UIntBE=Qe;class Ot extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readIntLE(t,this.span)}encode(e,t,n=0){return oe(t).writeIntLE(e,n,this.span),this.span}}w.Int=Ot;class Xt extends ue{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return oe(e).readIntBE(t,this.span)}encode(e,t,n=0){return oe(t).writeIntBE(e,n,this.span),this.span}}w.IntBE=Xt;const Er=Math.pow(2,32);function jn(r){const e=Math.floor(r/Er),t=r-e*Er;return{hi32:e,lo32:t}}function Gn(r,e){return r*Er+e}class Oo extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),s=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return Gn(o,s)}encode(e,t,n=0){const s=jn(e),o=oe(t);return o.writeUInt32LE(s.lo32,n),o.writeUInt32LE(s.hi32,n+4),8}}w.NearUInt64=Oo;class Uo extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),s=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return Gn(s,o)}encode(e,t,n=0){const s=jn(e),o=oe(t);return o.writeUInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}w.NearUInt64BE=Uo;class No extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),s=n.readUInt32LE(t),o=n.readInt32LE(t+4);return Gn(o,s)}encode(e,t,n=0){const s=jn(e),o=oe(t);return o.writeUInt32LE(s.lo32,n),o.writeInt32LE(s.hi32,n+4),8}}w.NearInt64=No;class qo extends ue{constructor(e){super(8,e)}decode(e,t=0){const n=oe(e),s=n.readInt32BE(t),o=n.readUInt32BE(t+4);return Gn(s,o)}encode(e,t,n=0){const s=jn(e),o=oe(t);return o.writeInt32BE(s.hi32,n),o.writeUInt32BE(s.lo32,n+4),8}}w.NearInt64BE=qo;class Fo extends ue{constructor(e){super(4,e)}decode(e,t=0){return oe(e).readFloatLE(t)}encode(e,t,n=0){return oe(t).writeFloatLE(e,n),4}}w.Float=Fo;class zo extends ue{constructor(e){super(4,e)}decode(e,t=0){return oe(e).readFloatBE(t)}encode(e,t,n=0){return oe(t).writeFloatBE(e,n),4}}w.FloatBE=zo;class Do extends ue{constructor(e){super(8,e)}decode(e,t=0){return oe(e).readDoubleLE(t)}encode(e,t,n=0){return oe(t).writeDoubleLE(e,n),8}}w.Double=Do;class Mo extends ue{constructor(e){super(8,e)}decode(e,t=0){return oe(e).readDoubleBE(t)}encode(e,t,n=0){return oe(t).writeDoubleBE(e,n),8}}w.DoubleBE=Mo;class Ko extends ue{constructor(e,t,n){if(!(e instanceof ue))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Fe&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof Fe)&&0<e.span&&(s=t*e.span),super(s,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,s=this.count;if(s instanceof Fe&&(s=s.decode(e,t)),0<this.elementLayout.span)n=s*this.elementLayout.span;else{let o=0;for(;o<s;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){const n=[];let s=0,o=this.count;for(o instanceof Fe&&(o=o.decode(e,t));s<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return n}encode(e,t,n=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,n+i),0);return this.count instanceof Fe&&this.count.encode(e.length,t,n),o}}w.Sequence=Ko;class Ho extends ue{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof ue,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){Yt(e);const n=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(n[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const s=n;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}w.Structure=Ho;class Hr{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}w.UnionDiscriminator=Hr;class In extends Hr{constructor(e,t){if(!(e instanceof Fe&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}w.UnionLayoutDiscriminator=In;class Wr extends ue{constructor(e,t,n){let s;if(e instanceof Ze||e instanceof Qe)s=new In(new Kr(e));else if(e instanceof Fe&&e.isCount())s=new In(e);else if(e instanceof Hr)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof ue))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof Ze||e instanceof Qe)&&(o+=s.layout.span)),super(o,n),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof Ze||e instanceof Qe,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),n=this.makeDestinationObject(),n[s.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return s.encode(e,t,n)}addVariant(e,t,n){const s=new Wo(this,e,t,n);return this.registry[e]=s,s}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}w.Union=Wr;class Wo extends ue{constructor(e,t,n,s){if(!(e instanceof Wr))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&s===void 0&&(s=n,n=null),n){if(!(n instanceof ue))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+n)),n+s}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+s):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,n+s),o+=this.layout.getSpan(t,n+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}w.VariantLayout=Wo;function Dt(r){return 0>r&&(r+=4294967296),r}class $r extends ue{constructor(e,t,n){if(!(e instanceof Ze||e instanceof Qe))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=Dt(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const n=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){const s=this.word.decode(t,n);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new jr(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new $o(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}w.BitStructure=$r;class jr{constructor(e,t,n){if(!(e instanceof $r))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=Dt(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return Dt(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Dt(e&this.valueMask))throw new TypeError(Mr("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=Dt(e<<this.start);this.container._packedSetValue(Dt(t&~this.wordMask)|n)}}w.BitField=jr;let $o=class extends jr{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};w.Boolean=$o;class jo extends ue{constructor(e,t){if(!(e instanceof Fe&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof Fe||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),oe(e).slice(t,t+n)}encode(e,t,n){let s=this.length;if(this.length instanceof Fe&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(Mr("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(n+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=oe(e);return oe(t).write(o.toString("hex"),n,s,"hex"),this.length instanceof Fe&&this.length.encode(s,t,n),s}}w.Blob=jo;class Go extends ue{constructor(e){super(-1,e)}getSpan(e,t=0){Yt(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return oe(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=Dr.Buffer.from(e,"utf8"),o=s.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");const i=oe(t);return s.copy(i,n),i[n+o]=0,o+1}}w.CString=Go;class Vo extends ue{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Yt(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return oe(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const s=Dr.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(oe(t),n),o}}w.UTF8=Vo;class Zo extends ue{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}w.Constant=Zo;w.greedy=(r,e)=>new Po(r,e);var Lt=w.offset=(r,e,t)=>new Kr(r,e,t),se=w.u8=r=>new Ze(1,r),Ve=w.u16=r=>new Ze(2,r);w.u24=r=>new Ze(3,r);var G=w.u32=r=>new Ze(4,r);w.u40=r=>new Ze(5,r);w.u48=r=>new Ze(6,r);var Ie=w.nu64=r=>new Oo(r);w.u16be=r=>new Qe(2,r);w.u24be=r=>new Qe(3,r);w.u32be=r=>new Qe(4,r);w.u40be=r=>new Qe(5,r);w.u48be=r=>new Qe(6,r);w.nu64be=r=>new Uo(r);w.s8=r=>new Ot(1,r);w.s16=r=>new Ot(2,r);w.s24=r=>new Ot(3,r);w.s32=r=>new Ot(4,r);w.s40=r=>new Ot(5,r);w.s48=r=>new Ot(6,r);var Me=w.ns64=r=>new No(r);w.s16be=r=>new Xt(2,r);w.s24be=r=>new Xt(3,r);w.s32be=r=>new Xt(4,r);w.s40be=r=>new Xt(5,r);w.s48be=r=>new Xt(6,r);w.ns64be=r=>new qo(r);w.f32=r=>new Fo(r);w.f32be=r=>new zo(r);w.f64=r=>new Do(r);w.f64be=r=>new Mo(r);var K=w.struct=(r,e,t)=>new Ho(r,e,t);w.bits=(r,e,t)=>new $r(r,e,t);var Ue=w.seq=(r,e,t)=>new Ko(r,e,t);w.union=(r,e,t)=>new Wr(r,e,t);w.unionLayoutDiscriminator=(r,e)=>new In(r,e);var fe=w.blob=(r,e)=>new jo(r,e);w.cstr=r=>new Go(r);w.utf8=(r,e)=>new Vo(r,e);w.constant=(r,e)=>new Zo(r,e);var fn={};Object.defineProperty(fn,"__esModule",{value:!0});function jc(r){{const e=xe.from(r);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var Yo=fn.toBigIntLE=jc;function Gc(r){{const e=r.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}fn.toBigIntBE=Gc;function Vc(r,e){{const t=r.toString(16),n=xe.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var Xo=fn.toBufferLE=Vc;function Zc(r,e){{const t=r.toString(16);return xe.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}fn.toBufferBE=Zc;class Yc extends TypeError{constructor(e,t){let n;const{message:s,...o}=e,{path:i}=e,a=i.length===0?s:"At path: "+i.join(".")+" -- "+s;super(a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var c;return(c=n)!=null?c:n=[e,...t()]}}}function Xc(r){return kt(r)&&typeof r[Symbol.iterator]=="function"}function kt(r){return typeof r=="object"&&r!=null}function et(r){return typeof r=="string"?JSON.stringify(r):""+r}function Jc(r){const{done:e,value:t}=r.next();return e?void 0:t}function Qc(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+et(n)+"`"}=r;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...r,message:c}}function*Es(r,e,t,n){Xc(r)||(r=[r]);for(const s of r){const o=Qc(s,e,t,n);o&&(yield o)}}function*Gr(r,e,t={}){const{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s};if(o&&(r=e.coercer(r,a),i&&e.type!=="type"&&kt(e.schema)&&kt(r)&&!Array.isArray(r)))for(const u in r)e.schema[u]===void 0&&delete r[u];let c=!0;for(const u of e.validator(r,a))c=!1,yield[u,void 0];for(let[u,l,d]of e.entries(r,a)){const k=Gr(l,d,{path:u===void 0?n:[...n,u],branch:u===void 0?s:[...s,l],coerce:o,mask:i});for(const m of k)m[0]?(c=!1,yield[m[0],void 0]):o&&(l=m[1],u===void 0?r=l:r instanceof Map?r.set(u,l):r instanceof Set?r.add(l):kt(r)&&(r[u]=l))}if(c)for(const u of e.refiner(r,a))c=!1,yield[u,void 0];c&&(yield[void 0,r])}let ut=class{constructor(e){const{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,u)=>{const l=s(c,u);return Es(l,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const l=o(c,u);return Es(l,u,this,c)}:this.refiner=()=>[]}assert(e){return eu(e,this)}create(e){return F(e,this)}is(e){return Jo(e,this)}mask(e){return tu(e,this)}validate(e,t={}){return dn(e,this,t)}};function eu(r,e){const t=dn(r,e);if(t[0])throw t[0]}function F(r,e){const t=dn(r,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function tu(r,e){const t=dn(r,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function Jo(r,e){return!dn(r,e)[0]}function dn(r,e,t={}){const n=Gr(r,e,t),s=Jc(n);return s[0]?[new Yc(s[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function Ut(r,e){return new ut({type:r,schema:null,validator:e})}function nu(){return Ut("any",()=>!0)}function D(r){return new ut({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+et(e)}})}function it(){return Ut("boolean",r=>typeof r=="boolean")}function Vr(r){return Ut("instance",e=>e instanceof r||"Expected a `"+r.name+"` instance, but received: "+et(e))}function ye(r){const e=et(r),t=typeof r;return new ut({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||"Expected the literal `"+e+"`, but received: "+et(n)}})}function ru(){return Ut("never",()=>!1)}function z(r){return new ut({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function b(){return Ut("number",r=>typeof r=="number"&&!isNaN(r)||"Expected a number, but received: "+et(r))}function X(r){return new ut({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function Qo(r,e){return new ut({type:"record",schema:null,*entries(t){if(kt(t))for(const n in t){const s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return kt(t)||"Expected an object, but received: "+et(t)}})}function q(){return Ut("string",r=>typeof r=="string"||"Expected a string, but received: "+et(r))}function Zr(r){const e=ru();return new ut({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+et(t)}})}function T(r){const e=Object.keys(r);return new ut({type:"type",schema:r,*entries(t){if(kt(t))for(const n of e)yield[n,t[n],r[n]]},validator(t){return kt(t)||"Expected an object, but received: "+et(t)}})}function ze(r){const e=r.map(t=>t.type).join(" | ");return new ut({type:"union",schema:null,validator(t,n){const s=[];for(const o of r){const[...i]=Gr(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+et(t),...s]}})}function hn(){return Ut("unknown",()=>!0)}function pn(r,e,t){return new ut({...r,coercer:(n,s)=>Jo(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}var vn,su=new Uint8Array(16);function ei(){if(!vn&&(vn=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!vn))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return vn(su)}const ou=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function Vn(r){return typeof r=="string"&&ou.test(r)}var Ae=[];for(var ar=0;ar<256;++ar)Ae.push((ar+256).toString(16).substr(1));function Zn(r){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(Ae[r[e+0]]+Ae[r[e+1]]+Ae[r[e+2]]+Ae[r[e+3]]+"-"+Ae[r[e+4]]+Ae[r[e+5]]+"-"+Ae[r[e+6]]+Ae[r[e+7]]+"-"+Ae[r[e+8]]+Ae[r[e+9]]+"-"+Ae[r[e+10]]+Ae[r[e+11]]+Ae[r[e+12]]+Ae[r[e+13]]+Ae[r[e+14]]+Ae[r[e+15]]).toLowerCase();if(!Vn(t))throw TypeError("Stringified UUID is invalid");return t}var _s,cr,ur=0,lr=0;function iu(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||_s,i=r.clockseq!==void 0?r.clockseq:cr;if(o==null||i==null){var a=r.random||(r.rng||ei)();o==null&&(o=_s=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=cr=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),u=r.nsecs!==void 0?r.nsecs:lr+1,l=c-ur+(u-lr)/1e4;if(l<0&&r.clockseq===void 0&&(i=i+1&16383),(l<0||c>ur)&&r.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");ur=c,lr=u,cr=i,c+=122192928e5;var d=((c&268435455)*1e4+u)%4294967296;s[n++]=d>>>24&255,s[n++]=d>>>16&255,s[n++]=d>>>8&255,s[n++]=d&255;var k=c/4294967296*1e4&268435455;s[n++]=k>>>8&255,s[n++]=k&255,s[n++]=k>>>24&15|16,s[n++]=k>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var m=0;m<6;++m)s[n+m]=o[m];return e||Zn(s)}function ti(r){if(!Vn(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function au(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}var cu="6ba7b810-9dad-11d1-80b4-00c04fd430c8",uu="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function ni(r,e,t){function n(s,o,i,a){if(typeof s=="string"&&(s=au(s)),typeof o=="string"&&(o=ti(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var u=0;u<16;++u)i[a+u]=c[u];return i}return Zn(c)}try{n.name=r}catch{}return n.DNS=cu,n.URL=uu,n}function lu(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return fu(du(hu(r),r.length*8))}function fu(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function ri(r){return(r+64>>>9<<4)+14+1}function du(r,e){r[e>>5]|=128<<e%32,r[ri(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var a=t,c=n,u=s,l=o;t=Le(t,n,s,o,r[i],7,-680876936),o=Le(o,t,n,s,r[i+1],12,-389564586),s=Le(s,o,t,n,r[i+2],17,606105819),n=Le(n,s,o,t,r[i+3],22,-1044525330),t=Le(t,n,s,o,r[i+4],7,-176418897),o=Le(o,t,n,s,r[i+5],12,1200080426),s=Le(s,o,t,n,r[i+6],17,-1473231341),n=Le(n,s,o,t,r[i+7],22,-45705983),t=Le(t,n,s,o,r[i+8],7,1770035416),o=Le(o,t,n,s,r[i+9],12,-1958414417),s=Le(s,o,t,n,r[i+10],17,-42063),n=Le(n,s,o,t,r[i+11],22,-1990404162),t=Le(t,n,s,o,r[i+12],7,1804603682),o=Le(o,t,n,s,r[i+13],12,-40341101),s=Le(s,o,t,n,r[i+14],17,-1502002290),n=Le(n,s,o,t,r[i+15],22,1236535329),t=Ce(t,n,s,o,r[i+1],5,-165796510),o=Ce(o,t,n,s,r[i+6],9,-1069501632),s=Ce(s,o,t,n,r[i+11],14,643717713),n=Ce(n,s,o,t,r[i],20,-373897302),t=Ce(t,n,s,o,r[i+5],5,-701558691),o=Ce(o,t,n,s,r[i+10],9,38016083),s=Ce(s,o,t,n,r[i+15],14,-660478335),n=Ce(n,s,o,t,r[i+4],20,-405537848),t=Ce(t,n,s,o,r[i+9],5,568446438),o=Ce(o,t,n,s,r[i+14],9,-1019803690),s=Ce(s,o,t,n,r[i+3],14,-187363961),n=Ce(n,s,o,t,r[i+8],20,1163531501),t=Ce(t,n,s,o,r[i+13],5,-1444681467),o=Ce(o,t,n,s,r[i+2],9,-51403784),s=Ce(s,o,t,n,r[i+7],14,1735328473),n=Ce(n,s,o,t,r[i+12],20,-1926607734),t=Pe(t,n,s,o,r[i+5],4,-378558),o=Pe(o,t,n,s,r[i+8],11,-2022574463),s=Pe(s,o,t,n,r[i+11],16,1839030562),n=Pe(n,s,o,t,r[i+14],23,-35309556),t=Pe(t,n,s,o,r[i+1],4,-1530992060),o=Pe(o,t,n,s,r[i+4],11,1272893353),s=Pe(s,o,t,n,r[i+7],16,-155497632),n=Pe(n,s,o,t,r[i+10],23,-1094730640),t=Pe(t,n,s,o,r[i+13],4,681279174),o=Pe(o,t,n,s,r[i],11,-358537222),s=Pe(s,o,t,n,r[i+3],16,-722521979),n=Pe(n,s,o,t,r[i+6],23,76029189),t=Pe(t,n,s,o,r[i+9],4,-640364487),o=Pe(o,t,n,s,r[i+12],11,-421815835),s=Pe(s,o,t,n,r[i+15],16,530742520),n=Pe(n,s,o,t,r[i+2],23,-995338651),t=Oe(t,n,s,o,r[i],6,-198630844),o=Oe(o,t,n,s,r[i+7],10,1126891415),s=Oe(s,o,t,n,r[i+14],15,-1416354905),n=Oe(n,s,o,t,r[i+5],21,-57434055),t=Oe(t,n,s,o,r[i+12],6,1700485571),o=Oe(o,t,n,s,r[i+3],10,-1894986606),s=Oe(s,o,t,n,r[i+10],15,-1051523),n=Oe(n,s,o,t,r[i+1],21,-2054922799),t=Oe(t,n,s,o,r[i+8],6,1873313359),o=Oe(o,t,n,s,r[i+15],10,-30611744),s=Oe(s,o,t,n,r[i+6],15,-1560198380),n=Oe(n,s,o,t,r[i+13],21,1309151649),t=Oe(t,n,s,o,r[i+4],6,-145523070),o=Oe(o,t,n,s,r[i+11],10,-1120210379),s=Oe(s,o,t,n,r[i+2],15,718787259),n=Oe(n,s,o,t,r[i+9],21,-343485551),t=xt(t,a),n=xt(n,c),s=xt(s,u),o=xt(o,l)}return[t,n,s,o]}function hu(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(ri(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function xt(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function pu(r,e){return r<<e|r>>>32-e}function Yn(r,e,t,n,s,o){return xt(pu(xt(xt(e,r),xt(n,o)),s),t)}function Le(r,e,t,n,s,o,i){return Yn(e&t|~e&n,r,e,s,o,i)}function Ce(r,e,t,n,s,o,i){return Yn(e&n|t&~n,r,e,s,o,i)}function Pe(r,e,t,n,s,o,i){return Yn(e^t^n,r,e,s,o,i)}function Oe(r,e,t,n,s,o,i){return Yn(t^(e|~n),r,e,s,o,i)}var gu=ni("v3",48,lu);const yu=gu;function bu(r,e,t){r=r||{};var n=r.random||(r.rng||ei)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=n[s];return e}return Zn(n)}function wu(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function fr(r,e){return r<<e|r>>>32-e}function mu(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var u=new Uint32Array(16),l=0;l<16;++l)u[l]=r[c*64+l*4]<<24|r[c*64+l*4+1]<<16|r[c*64+l*4+2]<<8|r[c*64+l*4+3];a[c]=u}a[i-1][14]=(r.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(r.length-1)*8&4294967295;for(var d=0;d<i;++d){for(var k=new Uint32Array(80),m=0;m<16;++m)k[m]=a[d][m];for(var y=16;y<80;++y)k[y]=fr(k[y-3]^k[y-8]^k[y-14]^k[y-16],1);for(var f=t[0],p=t[1],S=t[2],B=t[3],x=t[4],_=0;_<80;++_){var I=Math.floor(_/20),v=fr(f,5)+wu(I,p,S,B)+x+e[I]+k[_]>>>0;x=B,B=S,S=fr(p,30)>>>0,p=f,f=v}t[0]=t[0]+f>>>0,t[1]=t[1]+p>>>0,t[2]=t[2]+S>>>0,t[3]=t[3]+B>>>0,t[4]=t[4]+x>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var vu=ni("v5",80,mu);const Su=vu,xu="00000000-0000-0000-0000-000000000000";function ku(r){if(!Vn(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}const Eu=Object.freeze(Object.defineProperty({__proto__:null,NIL:xu,parse:ti,stringify:Zn,v1:iu,v3:yu,v4:bu,v5:Su,validate:Vn,version:ku},Symbol.toStringTag,{value:"Module"})),si=to(Eu),_u=si.v4,Bu=function(r,e,t,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};const s=typeof n.version=="number"?n.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:r};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return _u()};o.id=i(o,n)}else s===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};var Au=Bu;const Iu=si.v4,Ru=Au,sn=function(r,e){if(!(this instanceof sn))return new sn(r,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Iu()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=r};var Tu=sn;sn.prototype.request=function(r,e,t,n){const s=this;let o=null;const i=Array.isArray(r)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&r&&typeof r=="object"&&typeof e=="function")n=e,o=r;else{typeof t=="function"&&(n=t,t=void 0);const u=typeof n=="function";try{o=Ru(r,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(l){if(u)return n(l);throw l}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return n(u)}return this.callServer(c,function(u,l){s._parseResponse(u,l,n)}),o};sn.prototype._parseResponse=function(r,e,t){if(r){t(r);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(n)){const s=function(i){return typeof i.error<"u"},o=function(i){return!s(i)};return t(null,n.filter(s),n.filter(o))}else return t(null,n.error,n.result);t(null,n)};var oi={},on={},Lu={get exports(){return on},set exports(r){on=r}};(function(r){function e(t){return t&&t.__esModule?t:{default:t}}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports})(Lu);var Rn={},Cu={get exports(){return Rn},set exports(r){Rn=r}},Tn={},Pu={get exports(){return Tn},set exports(r){Tn=r}},Bs;function gn(){return Bs||(Bs=1,function(r){function e(t){return r.exports=e=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(n){return typeof n}:function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},r.exports.__esModule=!0,r.exports.default=r.exports,e(t)}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Pu)),Tn}var As;function Ou(){return As||(As=1,function(r){var e=gn().default;function t(){r.exports=t=function(){return s},r.exports.__esModule=!0,r.exports.default=r.exports;var n,s={},o=Object.prototype,i=o.hasOwnProperty,a=Object.defineProperty||function(h,g,E){h[g]=E.value},c=typeof Symbol=="function"?Symbol:{},u=c.iterator||"@@iterator",l=c.asyncIterator||"@@asyncIterator",d=c.toStringTag||"@@toStringTag";function k(h,g,E){return Object.defineProperty(h,g,{value:E,enumerable:!0,configurable:!0,writable:!0}),h[g]}try{k({},"")}catch{k=function(E,L,U){return E[L]=U}}function m(h,g,E,L){var U=g&&g.prototype instanceof _?g:_,O=Object.create(U.prototype),Z=new $(L||[]);return a(O,"_invoke",{value:ae(h,E,Z)}),O}function y(h,g,E){try{return{type:"normal",arg:h.call(g,E)}}catch(L){return{type:"throw",arg:L}}}s.wrap=m;var f="suspendedStart",p="suspendedYield",S="executing",B="completed",x={};function _(){}function I(){}function v(){}var R={};k(R,u,function(){return this});var A=Object.getPrototypeOf,M=A&&A(A(C([])));M&&M!==o&&i.call(M,u)&&(R=M);var j=v.prototype=_.prototype=Object.create(R);function V(h){["next","throw","return"].forEach(function(g){k(h,g,function(E){return this._invoke(g,E)})})}function ie(h,g){function E(U,O,Z,Y){var J=y(h[U],h,O);if(J.type!=="throw"){var le=J.arg,ce=le.value;return ce&&e(ce)=="object"&&i.call(ce,"__await")?g.resolve(ce.__await).then(function(de){E("next",de,Z,Y)},function(de){E("throw",de,Z,Y)}):g.resolve(ce).then(function(de){le.value=de,Z(le)},function(de){return E("throw",de,Z,Y)})}Y(J.arg)}var L;a(this,"_invoke",{value:function(O,Z){function Y(){return new g(function(J,le){E(O,Z,J,le)})}return L=L?L.then(Y,Y):Y()}})}function ae(h,g,E){var L=f;return function(U,O){if(L===S)throw new Error("Generator is already running");if(L===B){if(U==="throw")throw O;return{value:n,done:!0}}for(E.method=U,E.arg=O;;){var Z=E.delegate;if(Z){var Y=Q(Z,E);if(Y){if(Y===x)continue;return Y}}if(E.method==="next")E.sent=E._sent=E.arg;else if(E.method==="throw"){if(L===f)throw L=B,E.arg;E.dispatchException(E.arg)}else E.method==="return"&&E.abrupt("return",E.arg);L=S;var J=y(h,g,E);if(J.type==="normal"){if(L=E.done?B:p,J.arg===x)continue;return{value:J.arg,done:E.done}}J.type==="throw"&&(L=B,E.method="throw",E.arg=J.arg)}}}function Q(h,g){var E=g.method,L=h.iterator[E];if(L===n)return g.delegate=null,E==="throw"&&h.iterator.return&&(g.method="return",g.arg=n,Q(h,g),g.method==="throw")||E!=="return"&&(g.method="throw",g.arg=new TypeError("The iterator does not provide a '"+E+"' method")),x;var U=y(L,h.iterator,g.arg);if(U.type==="throw")return g.method="throw",g.arg=U.arg,g.delegate=null,x;var O=U.arg;return O?O.done?(g[h.resultName]=O.value,g.next=h.nextLoc,g.method!=="return"&&(g.method="next",g.arg=n),g.delegate=null,x):O:(g.method="throw",g.arg=new TypeError("iterator result is not an object"),g.delegate=null,x)}function P(h){var g={tryLoc:h[0]};1 in h&&(g.catchLoc=h[1]),2 in h&&(g.finallyLoc=h[2],g.afterLoc=h[3]),this.tryEntries.push(g)}function N(h){var g=h.completion||{};g.type="normal",delete g.arg,h.completion=g}function $(h){this.tryEntries=[{tryLoc:"root"}],h.forEach(P,this),this.reset(!0)}function C(h){if(h||h===""){var g=h[u];if(g)return g.call(h);if(typeof h.next=="function")return h;if(!isNaN(h.length)){var E=-1,L=function U(){for(;++E<h.length;)if(i.call(h,E))return U.value=h[E],U.done=!1,U;return U.value=n,U.done=!0,U};return L.next=L}}throw new TypeError(e(h)+" is not iterable")}return I.prototype=v,a(j,"constructor",{value:v,configurable:!0}),a(v,"constructor",{value:I,configurable:!0}),I.displayName=k(v,d,"GeneratorFunction"),s.isGeneratorFunction=function(h){var g=typeof h=="function"&&h.constructor;return!!g&&(g===I||(g.displayName||g.name)==="GeneratorFunction")},s.mark=function(h){return Object.setPrototypeOf?Object.setPrototypeOf(h,v):(h.__proto__=v,k(h,d,"GeneratorFunction")),h.prototype=Object.create(j),h},s.awrap=function(h){return{__await:h}},V(ie.prototype),k(ie.prototype,l,function(){return this}),s.AsyncIterator=ie,s.async=function(h,g,E,L,U){U===void 0&&(U=Promise);var O=new ie(m(h,g,E,L),U);return s.isGeneratorFunction(g)?O:O.next().then(function(Z){return Z.done?Z.value:O.next()})},V(j),k(j,d,"Generator"),k(j,u,function(){return this}),k(j,"toString",function(){return"[object Generator]"}),s.keys=function(h){var g=Object(h),E=[];for(var L in g)E.push(L);return E.reverse(),function U(){for(;E.length;){var O=E.pop();if(O in g)return U.value=O,U.done=!1,U}return U.done=!0,U}},s.values=C,$.prototype={constructor:$,reset:function(g){if(this.prev=0,this.next=0,this.sent=this._sent=n,this.done=!1,this.delegate=null,this.method="next",this.arg=n,this.tryEntries.forEach(N),!g)for(var E in this)E.charAt(0)==="t"&&i.call(this,E)&&!isNaN(+E.slice(1))&&(this[E]=n)},stop:function(){this.done=!0;var g=this.tryEntries[0].completion;if(g.type==="throw")throw g.arg;return this.rval},dispatchException:function(g){if(this.done)throw g;var E=this;function L(le,ce){return Z.type="throw",Z.arg=g,E.next=le,ce&&(E.method="next",E.arg=n),!!ce}for(var U=this.tryEntries.length-1;U>=0;--U){var O=this.tryEntries[U],Z=O.completion;if(O.tryLoc==="root")return L("end");if(O.tryLoc<=this.prev){var Y=i.call(O,"catchLoc"),J=i.call(O,"finallyLoc");if(Y&&J){if(this.prev<O.catchLoc)return L(O.catchLoc,!0);if(this.prev<O.finallyLoc)return L(O.finallyLoc)}else if(Y){if(this.prev<O.catchLoc)return L(O.catchLoc,!0)}else{if(!J)throw new Error("try statement without catch or finally");if(this.prev<O.finallyLoc)return L(O.finallyLoc)}}}},abrupt:function(g,E){for(var L=this.tryEntries.length-1;L>=0;--L){var U=this.tryEntries[L];if(U.tryLoc<=this.prev&&i.call(U,"finallyLoc")&&this.prev<U.finallyLoc){var O=U;break}}O&&(g==="break"||g==="continue")&&O.tryLoc<=E&&E<=O.finallyLoc&&(O=null);var Z=O?O.completion:{};return Z.type=g,Z.arg=E,O?(this.method="next",this.next=O.finallyLoc,x):this.complete(Z)},complete:function(g,E){if(g.type==="throw")throw g.arg;return g.type==="break"||g.type==="continue"?this.next=g.arg:g.type==="return"?(this.rval=this.arg=g.arg,this.method="return",this.next="end"):g.type==="normal"&&E&&(this.next=E),x},finish:function(g){for(var E=this.tryEntries.length-1;E>=0;--E){var L=this.tryEntries[E];if(L.finallyLoc===g)return this.complete(L.completion,L.afterLoc),N(L),x}},catch:function(g){for(var E=this.tryEntries.length-1;E>=0;--E){var L=this.tryEntries[E];if(L.tryLoc===g){var U=L.completion;if(U.type==="throw"){var O=U.arg;N(L)}return O}}throw new Error("illegal catch attempt")},delegateYield:function(g,E,L){return this.delegate={iterator:C(g),resultName:E,nextLoc:L},this.method==="next"&&(this.arg=n),x}},s}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(Cu)),Rn}var dr,Is;function Uu(){if(Is)return dr;Is=1;var r=Ou()();dr=r;try{regeneratorRuntime=r}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}return dr}var Ln={},Nu={get exports(){return Ln},set exports(r){Ln=r}},Rs;function qu(){return Rs||(Rs=1,function(r){function e(n,s,o,i,a,c,u){try{var l=n[c](u),d=l.value}catch(k){o(k);return}l.done?s(d):Promise.resolve(d).then(i,a)}function t(n){return function(){var s=this,o=arguments;return new Promise(function(i,a){var c=n.apply(s,o);function u(d){e(c,i,a,u,l,"next",d)}function l(d){e(c,i,a,u,l,"throw",d)}u(void 0)})}}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(Nu)),Ln}var Cn={},Fu={get exports(){return Cn},set exports(r){Cn=r}},Ts;function Yr(){return Ts||(Ts=1,function(r){function e(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Fu)),Cn}var Pn={},zu={get exports(){return Pn},set exports(r){Pn=r}},On={},Du={get exports(){return On},set exports(r){On=r}},Un={},Mu={get exports(){return Un},set exports(r){Un=r}},Ls;function Ku(){return Ls||(Ls=1,function(r){var e=gn().default;function t(n,s){if(e(n)!="object"||!n)return n;var o=n[Symbol.toPrimitive];if(o!==void 0){var i=o.call(n,s||"default");if(e(i)!="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(s==="string"?String:Number)(n)}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(Mu)),Un}var Cs;function Hu(){return Cs||(Cs=1,function(r){var e=gn().default,t=Ku();function n(s){var o=t(s,"string");return e(o)=="symbol"?o:String(o)}r.exports=n,r.exports.__esModule=!0,r.exports.default=r.exports}(Du)),On}var Ps;function Xr(){return Ps||(Ps=1,function(r){var e=Hu();function t(s,o){for(var i=0;i<o.length;i++){var a=o[i];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(s,e(a.key),a)}}function n(s,o,i){return o&&t(s.prototype,o),i&&t(s,i),Object.defineProperty(s,"prototype",{writable:!1}),s}r.exports=n,r.exports.__esModule=!0,r.exports.default=r.exports}(zu)),Pn}var Nn={},Wu={get exports(){return Nn},set exports(r){Nn=r}},qn={},$u={get exports(){return qn},set exports(r){qn=r}},Os;function ju(){return Os||(Os=1,function(r){function e(t,n){return r.exports=e=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(o,i){return o.__proto__=i,o},r.exports.__esModule=!0,r.exports.default=r.exports,e(t,n)}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}($u)),qn}var Us;function ii(){return Us||(Us=1,function(r){var e=ju();function t(n,s){if(typeof s!="function"&&s!==null)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(s&&s.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),s&&e(n,s)}r.exports=t,r.exports.__esModule=!0,r.exports.default=r.exports}(Wu)),Nn}var Fn={},Gu={get exports(){return Fn},set exports(r){Fn=r}},zn={},Vu={get exports(){return zn},set exports(r){zn=r}},Ns;function Zu(){return Ns||(Ns=1,function(r){function e(t){if(t===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Vu)),zn}var qs;function ai(){return qs||(qs=1,function(r){var e=gn().default,t=Zu();function n(s,o){if(o&&(e(o)==="object"||typeof o=="function"))return o;if(o!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return t(s)}r.exports=n,r.exports.__esModule=!0,r.exports.default=r.exports}(Gu)),Fn}var Dn={},Yu={get exports(){return Dn},set exports(r){Dn=r}},Fs;function ci(){return Fs||(Fs=1,function(r){function e(t){return r.exports=e=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(s){return s.__proto__||Object.getPrototypeOf(s)},r.exports.__esModule=!0,r.exports.default=r.exports,e(t)}r.exports=e,r.exports.__esModule=!0,r.exports.default=r.exports}(Yu)),Dn}var zt={},zs;function Xu(){if(zs)return zt;zs=1;var r=on;Object.defineProperty(zt,"__esModule",{value:!0}),zt.DefaultDataPack=void 0,zt.createError=o;var e=r(Yr()),t=r(Xr()),n=new Map([[-32e3,"Event not provided"],[-32600,"Invalid Request"],[-32601,"Method not found"],[-32602,"Invalid params"],[-32603,"Internal error"],[-32604,"Params not found"],[-32605,"Method forbidden"],[-32606,"Event forbidden"],[-32700,"Parse error"]]),s=function(){function i(){(0,e.default)(this,i)}return(0,t.default)(i,[{key:"encode",value:function(c){return JSON.stringify(c)}},{key:"decode",value:function(c){return JSON.parse(c)}}]),i}();zt.DefaultDataPack=s;function o(i,a){var c={code:i,message:n.get(i)||"Internal Server Error"};return a&&(c.data=a),c}return zt}(function(r){var e=on;Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var t=e(Uu()),n=e(qu()),s=e(gn()),o=e(Yr()),i=e(Xr()),a=e(ii()),c=e(ai()),u=e(ci()),l=ro,d=Xu();function k(p){var S=m();return function(){var x=(0,u.default)(p),_;if(S){var I=(0,u.default)(this).constructor;_=Reflect.construct(x,arguments,I)}else _=x.apply(this,arguments);return(0,c.default)(this,_)}}function m(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var y=function(p,S){var B={};for(var x in p)Object.prototype.hasOwnProperty.call(p,x)&&S.indexOf(x)<0&&(B[x]=p[x]);if(p!=null&&typeof Object.getOwnPropertySymbols=="function")for(var _=0,x=Object.getOwnPropertySymbols(p);_<x.length;_++)S.indexOf(x[_])<0&&Object.prototype.propertyIsEnumerable.call(p,x[_])&&(B[x[_]]=p[x[_]]);return B},f=function(p){(0,a.default)(B,p);var S=k(B);function B(x){var _,I=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",v=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},R=arguments.length>3?arguments[3]:void 0,A=arguments.length>4?arguments[4]:void 0;(0,o.default)(this,B);var M=v.autoconnect,j=M===void 0?!0:M,V=v.reconnect,ie=V===void 0?!0:V,ae=v.reconnect_interval,Q=ae===void 0?1e3:ae,P=v.max_reconnects,N=P===void 0?5:P,$=y(v,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return _=S.call(this),_.webSocketFactory=x,_.queue={},_.rpc_id=0,_.address=I,_.autoconnect=j,_.ready=!1,_.reconnect=ie,_.reconnect_timer_id=void 0,_.reconnect_interval=Q,_.max_reconnects=N,_.rest_options=$,_.current_reconnects=0,_.generate_request_id=R||function(){return++_.rpc_id},A?_.dataPack=A:_.dataPack=new d.DefaultDataPack,_.autoconnect&&_._connect(_.address,Object.assign({autoconnect:_.autoconnect,reconnect:_.reconnect,reconnect_interval:_.reconnect_interval,max_reconnects:_.max_reconnects},_.rest_options)),_}return(0,i.default)(B,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(_,I,v,R){var A=this;return!R&&(0,s.default)(v)==="object"&&(R=v,v=null),new Promise(function(M,j){if(!A.ready)return j(new Error("socket not ready"));var V=A.generate_request_id(_,I),ie={jsonrpc:"2.0",method:_,params:I||void 0,id:V};A.socket.send(A.dataPack.encode(ie),R,function(ae){if(ae)return j(ae);A.queue[V]={promise:[M,j]},v&&(A.queue[V].timeout=setTimeout(function(){delete A.queue[V],j(new Error("reply timeout"))},v))})})}},{key:"login",value:function(){var x=(0,n.default)(t.default.mark(function I(v){var R;return t.default.wrap(function(M){for(;;)switch(M.prev=M.next){case 0:return M.next=2,this.call("rpc.login",v);case 2:if(R=M.sent,R){M.next=5;break}throw new Error("authentication failed");case 5:return M.abrupt("return",R);case 6:case"end":return M.stop()}},I,this)}));function _(I){return x.apply(this,arguments)}return _}()},{key:"listMethods",value:function(){var x=(0,n.default)(t.default.mark(function I(){return t.default.wrap(function(R){for(;;)switch(R.prev=R.next){case 0:return R.next=2,this.call("__listMethods");case 2:return R.abrupt("return",R.sent);case 3:case"end":return R.stop()}},I,this)}));function _(){return x.apply(this,arguments)}return _}()},{key:"notify",value:function(_,I){var v=this;return new Promise(function(R,A){if(!v.ready)return A(new Error("socket not ready"));var M={jsonrpc:"2.0",method:_,params:I};v.socket.send(v.dataPack.encode(M),function(j){if(j)return A(j);R()})})}},{key:"subscribe",value:function(){var x=(0,n.default)(t.default.mark(function I(v){var R;return t.default.wrap(function(M){for(;;)switch(M.prev=M.next){case 0:return typeof v=="string"&&(v=[v]),M.next=3,this.call("rpc.on",v);case 3:if(R=M.sent,!(typeof v=="string"&&R[v]!=="ok")){M.next=6;break}throw new Error("Failed subscribing to an event '"+v+"' with: "+R[v]);case 6:return M.abrupt("return",R);case 7:case"end":return M.stop()}},I,this)}));function _(I){return x.apply(this,arguments)}return _}()},{key:"unsubscribe",value:function(){var x=(0,n.default)(t.default.mark(function I(v){var R;return t.default.wrap(function(M){for(;;)switch(M.prev=M.next){case 0:return typeof v=="string"&&(v=[v]),M.next=3,this.call("rpc.off",v);case 3:if(R=M.sent,!(typeof v=="string"&&R[v]!=="ok")){M.next=6;break}throw new Error("Failed unsubscribing from an event with: "+R);case 6:return M.abrupt("return",R);case 7:case"end":return M.stop()}},I,this)}));function _(I){return x.apply(this,arguments)}return _}()},{key:"close",value:function(_,I){this.socket.close(_||1e3,I)}},{key:"_connect",value:function(_,I){var v=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(_,I),this.socket.addEventListener("open",function(){v.ready=!0,v.emit("open"),v.current_reconnects=0}),this.socket.addEventListener("message",function(R){var A=R.data;A instanceof ArrayBuffer&&(A=xe.from(A).toString());try{A=v.dataPack.decode(A)}catch{return}if(A.notification&&v.listeners(A.notification).length){if(!Object.keys(A.params).length)return v.emit(A.notification);var M=[A.notification];if(A.params.constructor===Object)M.push(A.params);else for(var j=0;j<A.params.length;j++)M.push(A.params[j]);return Promise.resolve().then(function(){v.emit.apply(v,M)})}if(!v.queue[A.id])return A.method?Promise.resolve().then(function(){v.emit(A.method,A==null?void 0:A.params)}):void 0;"error"in A=="result"in A&&v.queue[A.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),v.queue[A.id].timeout&&clearTimeout(v.queue[A.id].timeout),A.error?v.queue[A.id].promise[1](A.error):v.queue[A.id].promise[0](A.result),delete v.queue[A.id]}),this.socket.addEventListener("error",function(R){return v.emit("error",R)}),this.socket.addEventListener("close",function(R){var A=R.code,M=R.reason;v.ready&&setTimeout(function(){return v.emit("close",A,M)},0),v.ready=!1,v.socket=void 0,A!==1e3&&(v.current_reconnects++,v.reconnect&&(v.max_reconnects>v.current_reconnects||v.max_reconnects===0)&&(v.reconnect_timer_id=setTimeout(function(){return v._connect(_,I)},v.reconnect_interval)))})}}]),B}(l.EventEmitter);r.default=f})(oi);const Ju=no(oi);var ui={};(function(r){var e=on;Object.defineProperty(r,"__esModule",{value:!0}),r.default=d;var t=e(Yr()),n=e(Xr()),s=e(ii()),o=e(ai()),i=e(ci()),a=ro;function c(k){var m=u();return function(){var f=(0,i.default)(k),p;if(m){var S=(0,i.default)(this).constructor;p=Reflect.construct(f,arguments,S)}else p=f.apply(this,arguments);return(0,o.default)(this,p)}}function u(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var l=function(k){(0,s.default)(y,k);var m=c(y);function y(f,p,S){var B;return(0,t.default)(this,y),B=m.call(this),B.socket=new window.WebSocket(f,S),B.socket.onopen=function(){return B.emit("open")},B.socket.onmessage=function(x){return B.emit("message",x.data)},B.socket.onerror=function(x){return B.emit("error",x)},B.socket.onclose=function(x){B.emit("close",x.code,x.reason)},B}return(0,n.default)(y,[{key:"send",value:function(p,S,B){var x=B||S;try{this.socket.send(p),x()}catch(_){x(_)}}},{key:"close",value:function(p,S){this.socket.close(p,S)}},{key:"addEventListener",value:function(p,S,B){this.socket.addEventListener(p,S,B)}}]),y}(a.EventEmitter);function d(k,m){return new l(k,m)}})(ui);const Qu=no(ui);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function el(r){const e=Or(r);Zt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:tl,hexToBytes:nl}=Ya,Rt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(r){const{Err:e}=Rt;if(r.length<2||r[0]!==2)throw new e("Invalid signature integer tag");const t=r[1],n=r.subarray(2,t+2);if(!t||n.length!==t)throw new e("Invalid signature integer: wrong length");if(n[0]&128)throw new e("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:tl(n),l:r.subarray(t+2)}},toSig(r){const{Err:e}=Rt,t=typeof r=="string"?nl(r):r;if(!ot(t))throw new Error("ui8a expected");let n=t.length;if(n<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=Rt._parseInt(t.subarray(2)),{d:i,l:a}=Rt._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(r){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,t=u=>{const l=u.toString(16);return l.length&1?`0${l}`:l},n=e(t(r.s)),s=e(t(r.r)),o=n.length/2,i=s.length/2,a=t(o),c=t(i);return`30${t(i+o+4)}02${c}${s}02${a}${n}`}},dt=BigInt(0),Ge=BigInt(1);BigInt(2);const Ds=BigInt(3);BigInt(4);function rl(r){const e=el(r),{Fp:t}=e,n=e.toBytes||((y,f,p)=>{const S=f.toAffine();return Pt(Uint8Array.from([4]),t.toBytes(S.x),t.toBytes(S.y))}),s=e.fromBytes||(y=>{const f=y.subarray(1),p=t.fromBytes(f.subarray(0,t.BYTES)),S=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:p,y:S}});function o(y){const{a:f,b:p}=e,S=t.sqr(y),B=t.mul(S,y);return t.add(t.add(B,t.mul(y,f)),p)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function i(y){return typeof y=="bigint"&&dt<y&&y<e.n}function a(y){if(!i(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(y){const{allowedPrivateKeyLengths:f,nByteLength:p,wrapPrivateKey:S,n:B}=e;if(f&&typeof y!="bigint"){if(ot(y)&&(y=Ct(y)),typeof y!="string"||!f.includes(y.length))throw new Error("Invalid key");y=y.padStart(p*2,"0")}let x;try{x=typeof y=="bigint"?y:Tt(ke("private key",y,p))}catch{throw new Error(`private key must be ${p} bytes, hex or bigint, not ${typeof y}`)}return S&&(x=ge(x,B)),a(x),x}const u=new Map;function l(y){if(!(y instanceof d))throw new Error("ProjectivePoint expected")}class d{constructor(f,p,S){if(this.px=f,this.py=p,this.pz=S,f==null||!t.isValid(f))throw new Error("x required");if(p==null||!t.isValid(p))throw new Error("y required");if(S==null||!t.isValid(S))throw new Error("z required")}static fromAffine(f){const{x:p,y:S}=f||{};if(!f||!t.isValid(p)||!t.isValid(S))throw new Error("invalid affine point");if(f instanceof d)throw new Error("projective point not allowed");const B=x=>t.eql(x,t.ZERO);return B(p)&&B(S)?d.ZERO:new d(p,S,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const p=t.invertBatch(f.map(S=>S.pz));return f.map((S,B)=>S.toAffine(p[B])).map(d.fromAffine)}static fromHex(f){const p=d.fromAffine(s(ke("pointHex",f)));return p.assertValidity(),p}static fromPrivateKey(f){return d.BASE.multiply(c(f))}_setWindowSize(f){this._WINDOW_SIZE=f,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:f,y:p}=this.toAffine();if(!t.isValid(f)||!t.isValid(p))throw new Error("bad point: x or y not FE");const S=t.sqr(p),B=o(f);if(!t.eql(S,B))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){l(f);const{px:p,py:S,pz:B}=this,{px:x,py:_,pz:I}=f,v=t.eql(t.mul(p,I),t.mul(x,B)),R=t.eql(t.mul(S,I),t.mul(_,B));return v&&R}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b:p}=e,S=t.mul(p,Ds),{px:B,py:x,pz:_}=this;let I=t.ZERO,v=t.ZERO,R=t.ZERO,A=t.mul(B,B),M=t.mul(x,x),j=t.mul(_,_),V=t.mul(B,x);return V=t.add(V,V),R=t.mul(B,_),R=t.add(R,R),I=t.mul(f,R),v=t.mul(S,j),v=t.add(I,v),I=t.sub(M,v),v=t.add(M,v),v=t.mul(I,v),I=t.mul(V,I),R=t.mul(S,R),j=t.mul(f,j),V=t.sub(A,j),V=t.mul(f,V),V=t.add(V,R),R=t.add(A,A),A=t.add(R,A),A=t.add(A,j),A=t.mul(A,V),v=t.add(v,A),j=t.mul(x,_),j=t.add(j,j),A=t.mul(j,V),I=t.sub(I,A),R=t.mul(j,M),R=t.add(R,R),R=t.add(R,R),new d(I,v,R)}add(f){l(f);const{px:p,py:S,pz:B}=this,{px:x,py:_,pz:I}=f;let v=t.ZERO,R=t.ZERO,A=t.ZERO;const M=e.a,j=t.mul(e.b,Ds);let V=t.mul(p,x),ie=t.mul(S,_),ae=t.mul(B,I),Q=t.add(p,S),P=t.add(x,_);Q=t.mul(Q,P),P=t.add(V,ie),Q=t.sub(Q,P),P=t.add(p,B);let N=t.add(x,I);return P=t.mul(P,N),N=t.add(V,ae),P=t.sub(P,N),N=t.add(S,B),v=t.add(_,I),N=t.mul(N,v),v=t.add(ie,ae),N=t.sub(N,v),A=t.mul(M,P),v=t.mul(j,ae),A=t.add(v,A),v=t.sub(ie,A),A=t.add(ie,A),R=t.mul(v,A),ie=t.add(V,V),ie=t.add(ie,V),ae=t.mul(M,ae),P=t.mul(j,P),ie=t.add(ie,ae),ae=t.sub(V,ae),ae=t.mul(M,ae),P=t.add(P,ae),V=t.mul(ie,P),R=t.add(R,V),V=t.mul(N,P),v=t.mul(Q,v),v=t.sub(v,V),V=t.mul(Q,ie),A=t.mul(N,A),A=t.add(A,V),new d(v,R,A)}subtract(f){return this.add(f.negate())}is0(){return this.equals(d.ZERO)}wNAF(f){return m.wNAFCached(this,u,f,p=>{const S=t.invertBatch(p.map(B=>B.pz));return p.map((B,x)=>B.toAffine(S[x])).map(d.fromAffine)})}multiplyUnsafe(f){const p=d.ZERO;if(f===dt)return p;if(a(f),f===Ge)return this;const{endo:S}=e;if(!S)return m.unsafeLadder(this,f);let{k1neg:B,k1:x,k2neg:_,k2:I}=S.splitScalar(f),v=p,R=p,A=this;for(;x>dt||I>dt;)x&Ge&&(v=v.add(A)),I&Ge&&(R=R.add(A)),A=A.double(),x>>=Ge,I>>=Ge;return B&&(v=v.negate()),_&&(R=R.negate()),R=new d(t.mul(R.px,S.beta),R.py,R.pz),v.add(R)}multiply(f){a(f);let p=f,S,B;const{endo:x}=e;if(x){const{k1neg:_,k1:I,k2neg:v,k2:R}=x.splitScalar(p);let{p:A,f:M}=this.wNAF(I),{p:j,f:V}=this.wNAF(R);A=m.constTimeNegate(_,A),j=m.constTimeNegate(v,j),j=new d(t.mul(j.px,x.beta),j.py,j.pz),S=A.add(j),B=M.add(V)}else{const{p:_,f:I}=this.wNAF(p);S=_,B=I}return d.normalizeZ([S,B])[0]}multiplyAndAddUnsafe(f,p,S){const B=d.BASE,x=(I,v)=>v===dt||v===Ge||!I.equals(B)?I.multiplyUnsafe(v):I.multiply(v),_=x(this,p).add(x(f,S));return _.is0()?void 0:_}toAffine(f){const{px:p,py:S,pz:B}=this,x=this.is0();f==null&&(f=x?t.ONE:t.inv(B));const _=t.mul(p,f),I=t.mul(S,f),v=t.mul(B,f);if(x)return{x:t.ZERO,y:t.ZERO};if(!t.eql(v,t.ONE))throw new Error("invZ was invalid");return{x:_,y:I}}isTorsionFree(){const{h:f,isTorsionFree:p}=e;if(f===Ge)return!0;if(p)return p(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:p}=e;return f===Ge?this:p?p(d,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return this.assertValidity(),n(d,this,f)}toHex(f=!0){return Ct(this.toRawBytes(f))}}d.BASE=new d(e.Gx,e.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);const k=e.nBitLength,m=ko(d,e.endo?Math.ceil(k/2):k);return{CURVE:e,ProjectivePoint:d,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:i}}function sl(r){const e=Or(r);return Zt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function ol(r){const e=sl(r),{Fp:t,n}=e,s=t.BYTES+1,o=2*t.BYTES+1;function i(P){return dt<P&&P<t.ORDER}function a(P){return ge(P,n)}function c(P){return Sr(P,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:k}=rl({...e,toBytes(P,N,$){const C=N.toAffine(),h=t.toBytes(C.x),g=Pt;return $?g(Uint8Array.from([N.hasEvenY()?2:3]),h):g(Uint8Array.from([4]),h,t.toBytes(C.y))},fromBytes(P){const N=P.length,$=P[0],C=P.subarray(1);if(N===s&&($===2||$===3)){const h=Tt(C);if(!i(h))throw new Error("Point is not on curve");const g=d(h);let E=t.sqrt(g);const L=(E&Ge)===Ge;return($&1)===1!==L&&(E=t.neg(E)),{x:h,y:E}}else if(N===o&&$===4){const h=t.fromBytes(C.subarray(0,t.BYTES)),g=t.fromBytes(C.subarray(t.BYTES,2*t.BYTES));return{x:h,y:g}}else throw new Error(`Point of length ${N} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),m=P=>Ct(jt(P,e.nByteLength));function y(P){const N=n>>Ge;return P>N}function f(P){return y(P)?a(-P):P}const p=(P,N,$)=>Tt(P.slice(N,$));class S{constructor(N,$,C){this.r=N,this.s=$,this.recovery=C,this.assertValidity()}static fromCompact(N){const $=e.nByteLength;return N=ke("compactSignature",N,$*2),new S(p(N,0,$),p(N,$,2*$))}static fromDER(N){const{r:$,s:C}=Rt.toSig(ke("DER",N));return new S($,C)}assertValidity(){if(!k(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!k(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(N){return new S(this.r,this.s,N)}recoverPublicKey(N){const{r:$,s:C,recovery:h}=this,g=R(ke("msgHash",N));if(h==null||![0,1,2,3].includes(h))throw new Error("recovery id invalid");const E=h===2||h===3?$+e.n:$;if(E>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const L=h&1?"03":"02",U=u.fromHex(L+m(E)),O=c(E),Z=a(-g*O),Y=a(C*O),J=u.BASE.multiplyAndAddUnsafe(U,Z,Y);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new S(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return $t(this.toDERHex())}toDERHex(){return Rt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return $t(this.toCompactHex())}toCompactHex(){return m(this.r)+m(this.s)}}const B={isValidPrivateKey(P){try{return l(P),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const P=xo(e.n);return ac(e.randomBytes(P),e.n)},precompute(P=8,N=u.BASE){return N._setWindowSize(P),N.multiply(BigInt(3)),N}};function x(P,N=!0){return u.fromPrivateKey(P).toRawBytes(N)}function _(P){const N=ot(P),$=typeof P=="string",C=(N||$)&&P.length;return N?C===s||C===o:$?C===2*s||C===2*o:P instanceof u}function I(P,N,$=!0){if(_(P))throw new Error("first arg must be private key");if(!_(N))throw new Error("second arg must be public key");return u.fromHex(N).multiply(l(P)).toRawBytes($)}const v=e.bits2int||function(P){const N=Tt(P),$=P.length*8-e.nBitLength;return $>0?N>>BigInt($):N},R=e.bits2int_modN||function(P){return a(v(P))},A=Pr(e.nBitLength);function M(P){if(typeof P!="bigint")throw new Error("bigint expected");if(!(dt<=P&&P<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return jt(P,e.nByteLength)}function j(P,N,$=V){if(["recovered","canonical"].some(ce=>ce in $))throw new Error("sign() legacy options not supported");const{hash:C,randomBytes:h}=e;let{lowS:g,prehash:E,extraEntropy:L}=$;g==null&&(g=!0),P=ke("msgHash",P),E&&(P=ke("prehashed msgHash",C(P)));const U=R(P),O=l(N),Z=[M(O),M(U)];if(L!=null){const ce=L===!0?h(t.BYTES):L;Z.push(ke("extraEntropy",ce))}const Y=Pt(...Z),J=U;function le(ce){const de=v(ce);if(!k(de))return;const Be=c(de),Ne=u.BASE.multiply(de).toAffine(),ve=a(Ne.x);if(ve===dt)return;const Ye=a(Be*a(J+ve*O));if(Ye===dt)return;let Et=(Ne.x===ve?0:2)|Number(Ne.y&Ge),Qt=Ye;return g&&y(Ye)&&(Qt=f(Ye),Et^=1),new S(ve,Qt,Et)}return{seed:Y,k2sig:le}}const V={lowS:e.lowS,prehash:!1},ie={lowS:e.lowS,prehash:!1};function ae(P,N,$=V){const{seed:C,k2sig:h}=j(P,N,$),g=e;return wo(g.hash.outputLen,g.nByteLength,g.hmac)(C,h)}u.BASE._setWindowSize(8);function Q(P,N,$,C=ie){var Ne;const h=P;if(N=ke("msgHash",N),$=ke("publicKey",$),"strict"in C)throw new Error("options.strict was renamed to lowS");const{lowS:g,prehash:E}=C;let L,U;try{if(typeof h=="string"||ot(h))try{L=S.fromDER(h)}catch(ve){if(!(ve instanceof Rt.Err))throw ve;L=S.fromCompact(h)}else if(typeof h=="object"&&typeof h.r=="bigint"&&typeof h.s=="bigint"){const{r:ve,s:Ye}=h;L=new S(ve,Ye)}else throw new Error("PARSE");U=u.fromHex($)}catch(ve){if(ve.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(g&&L.hasHighS())return!1;E&&(N=e.hash(N));const{r:O,s:Z}=L,Y=R(N),J=c(Z),le=a(Y*J),ce=a(O*J),de=(Ne=u.BASE.multiplyAndAddUnsafe(U,le,ce))==null?void 0:Ne.toAffine();return de?a(de.x)===O:!1}return{CURVE:e,getPublicKey:x,getSharedSecret:I,sign:ae,verify:Q,ProjectivePoint:u,Signature:S,utils:B}}class li extends uo{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,da(e);const n=Lr(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return kn(this),this.iHash.update(e),this}digestInto(e){kn(this),oo(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const fi=(r,e,t)=>new li(r,e).update(t).digest();fi.create=(r,e)=>new li(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function il(r){return{hash:r,hmac:(e,...t)=>fi(r,e,co(...t)),randomBytes:fo}}function al(r,e){const t=n=>ol({...r,...il(n)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const di=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ms=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),cl=BigInt(1),_r=BigInt(2),Ks=(r,e)=>(r+e/_r)/e;function ul(r){const e=di,t=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%e,l=u*u*r%e,d=we(l,t,e)*l%e,k=we(d,t,e)*l%e,m=we(k,_r,e)*u%e,y=we(m,s,e)*m%e,f=we(y,o,e)*y%e,p=we(f,a,e)*f%e,S=we(p,c,e)*p%e,B=we(S,a,e)*f%e,x=we(B,t,e)*l%e,_=we(x,i,e)*y%e,I=we(_,n,e)*u%e,v=we(I,_r,e);if(!Br.eql(Br.sqr(v),r))throw new Error("Cannot find square root");return v}const Br=vo(di,void 0,void 0,{sqrt:ul}),Jr=al({a:BigInt(0),b:BigInt(7),Fp:Br,n:Ms,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Ms,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-cl*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,i=BigInt("0x100000000000000000000000000000000"),a=Ks(o*r,e),c=Ks(-n*r,e);let u=ge(r-a*t-c*s,e),l=ge(-a*n-c*o,e);const d=u>i,k=l>i;if(d&&(u=e-u),k&&(l=e-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:u,k2neg:k,k2:l}}}},kr);BigInt(0);Jr.ProjectivePoint;ln.utils.randomPrivateKey;ln.getPublicKey;function Hs(r){try{return ln.ExtendedPoint.fromHex(r),!0}catch{return!1}}const hi=(r,e)=>ln.sign(r,e.slice(0,32)),ll=ln.verify,Re=r=>ee.Buffer.isBuffer(r)?r:r instanceof Uint8Array?ee.Buffer.from(r.buffer,r.byteOffset,r.byteLength):ee.Buffer.from(r);class fl{constructor(e){Object.assign(this,e)}encode(){return ee.Buffer.from(Lo(xn,this))}static decode(e){return Co(xn,this,e)}static decodeUnchecked(e){return Bo(xn,this,e)}}const xn=new Map;var pi;let gi;const dl=32,rt=32;function hl(r){return r._bn!==void 0}let Ws=1;gi=Symbol.toStringTag;class H extends fl{constructor(e){if(super({}),this._bn=void 0,hl(e))this._bn=e._bn;else{if(typeof e=="string"){const t=Ee.decode(e);if(t.length!=rt)throw new Error("Invalid public key input");this._bn=new br(t)}else this._bn=new br(e);if(this._bn.byteLength()>rt)throw new Error("Invalid public key input")}}static unique(){const e=new H(Ws);return Ws+=1,new H(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return Ee.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(ee.Buffer);if(e.length===rt)return e;const t=ee.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[gi](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=ee.Buffer.concat([e.toBuffer(),ee.Buffer.from(t),n.toBuffer()]),o=kr(s);return new H(o)}static createProgramAddressSync(e,t){let n=ee.Buffer.alloc(0);e.forEach(function(o){if(o.length>dl)throw new TypeError("Max seed length exceeded");n=ee.Buffer.concat([n,Re(o)])}),n=ee.Buffer.concat([n,t.toBuffer(),ee.Buffer.from("ProgramDerivedAddress")]);const s=kr(n);if(Hs(s))throw new Error("Invalid seeds, address must fall off the curve");return new H(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const o=e.concat(ee.Buffer.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new H(e);return Hs(t.toBytes())}}pi=H;H.default=new pi("11111111111111111111111111111111");xn.set(H,{kind:"struct",fields:[["_bn","u256"]]});new H("BPFLoader1111111111111111111111111111111111");const Wt=1280-40-8,Qr=127,an=64;class yi extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(yi.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class bi extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(bi.prototype,"name",{value:"TransactionExpiredTimeoutError"});class tn extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(tn.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Mn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});const s=o=>{const i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const re=(r="publicKey")=>fe(32,r),pl=(r="signature")=>fe(64,r),Kt=(r="string")=>{const e=K([G("length"),G("lengthPadding"),fe(Lt(G(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:ee.Buffer.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>G().span+G().span+ee.Buffer.from(o,"utf8").length,s},gl=(r="authorized")=>K([re("staker"),re("withdrawer")],r),yl=(r="lockup")=>K([Me("unixTimestamp"),Me("epoch"),re("custodian")],r),bl=(r="voteInit")=>K([re("nodePubkey"),re("authorizedVoter"),re("authorizedWithdrawer"),se("commission")],r),wl=(r="voteAuthorizeWithSeedArgs")=>K([G("voteAuthorizationType"),re("currentAuthorityDerivedKeyOwnerPubkey"),Kt("currentAuthorityDerivedKeySeed"),re("newAuthorized")],r);function wi(r,e){const t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){const o=e[s.property];if(Array.isArray(o))return o.length*t(s.elementLayout)}else if("fields"in s)return wi({layout:s},e[s.property]);return 0};let n=0;return r.layout.fields.forEach(s=>{n+=t(s)}),n}function Ke(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function He(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function pe(r,e){if(!r)throw new Error(e||"Assertion failed")}class Xn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Xn(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];pe(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{pe(t.length>0,"Expected at least one writable signer key");const[c]=t[0];pe(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new H(c)),...n.map(([c])=>new H(c)),...s.map(([c])=>new H(c)),...o.map(([c])=>new H(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new H(o),c=e.findIndex(u=>u.equals(a));c>=0&&(pe(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(o))}return[n,s]}}class gt{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new H(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Ee.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Mn(this.staticAccountKeys)}static compile(e){const t=Xn.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new Mn(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:Ee.encode(a.data)}));return new gt({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];He(t,e);const n=this.instructions.map(d=>{const{accounts:k,programIdIndex:m}=d,y=Array.from(Ee.decode(d.data));let f=[];He(f,k.length);let p=[];return He(p,y.length),{programIdIndex:m,keyIndicesCount:ee.Buffer.from(f),keyIndices:k,dataLength:ee.Buffer.from(p),data:y}});let s=[];He(s,n.length);let o=ee.Buffer.alloc(Wt);ee.Buffer.from(s).copy(o);let i=s.length;n.forEach(d=>{const m=K([se("programIdIndex"),fe(d.keyIndicesCount.length,"keyIndicesCount"),Ue(se("keyIndex"),d.keyIndices.length,"keyIndices"),fe(d.dataLength.length,"dataLength"),Ue(se("userdatum"),d.data.length,"data")]).encode(d,o,i);i+=m}),o=o.slice(0,i);const a=K([fe(1,"numRequiredSignatures"),fe(1,"numReadonlySignedAccounts"),fe(1,"numReadonlyUnsignedAccounts"),fe(t.length,"keyCount"),Ue(re("key"),e,"keys"),re("recentBlockhash")]),c={numRequiredSignatures:ee.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:ee.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:ee.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:ee.Buffer.from(t),keys:this.accountKeys.map(d=>Re(d.toBytes())),recentBlockhash:Ee.decode(this.recentBlockhash)};let u=ee.Buffer.alloc(2048);const l=a.encode(c,u);return o.copy(u,l),u.slice(0,l+o.length)}static from(e){let t=[...e];const n=t.shift();if(n!==(n&Qr))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=t.shift(),o=t.shift(),i=Ke(t);let a=[];for(let k=0;k<i;k++){const m=t.slice(0,rt);t=t.slice(rt),a.push(new H(ee.Buffer.from(m)))}const c=t.slice(0,rt);t=t.slice(rt);const u=Ke(t);let l=[];for(let k=0;k<u;k++){const m=t.shift(),y=Ke(t),f=t.slice(0,y);t=t.slice(y);const p=Ke(t),S=t.slice(0,p),B=Ee.encode(ee.Buffer.from(S));t=t.slice(p),l.push({programIdIndex:m,accounts:f,data:B})}const d={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:Ee.encode(ee.Buffer.from(c)),accountKeys:a,instructions:l};return new gt(d)}}class cn{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Mn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=Xn.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const l of o){const d=t.extractTableLookup(l);if(d!==void 0){const[k,{writable:m,readonly:y}]=d;n.push(k),s.writable.push(...m),s.readonly.push(...y)}}const[i,a]=t.getMessageComponents(),u=new Mn(a,s).compileInstructions(e.instructions);return new cn({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:u,addressTableLookups:n})}serialize(){const e=Array();He(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();He(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();He(o,this.addressTableLookups.length);const i=K([se("prefix"),K([se("numRequiredSignatures"),se("numReadonlySignedAccounts"),se("numReadonlyUnsignedAccounts")],"header"),fe(e.length,"staticAccountKeysLength"),Ue(re(),this.staticAccountKeys.length,"staticAccountKeys"),re("recentBlockhash"),fe(n.length,"instructionsLength"),fe(t.length,"serializedInstructions"),fe(o.length,"addressTableLookupsLength"),fe(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Wt),c=1<<7,u=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:Ee.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(Wt);for(const n of this.compiledInstructions){const s=Array();He(s,n.accountKeyIndexes.length);const o=Array();He(o,n.data.length);const i=K([se("programIdIndex"),fe(s.length,"encodedAccountKeyIndexesLength"),Ue(se(),n.accountKeyIndexes.length,"accountKeyIndexes"),fe(o.length,"encodedDataLength"),fe(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Wt);for(const n of this.addressTableLookups){const s=Array();He(s,n.writableIndexes.length);const o=Array();He(o,n.readonlyIndexes.length);const i=K([re("accountKey"),fe(s.length,"encodedWritableIndexesLength"),Ue(se(),n.writableIndexes.length,"writableIndexes"),fe(o.length,"encodedReadonlyIndexesLength"),Ue(se(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=t.shift(),s=n&Qr;pe(n!==s,"Expected versioned message but received legacy message");const o=s;pe(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},a=[],c=Ke(t);for(let y=0;y<c;y++)a.push(new H(t.splice(0,rt)));const u=Ee.encode(t.splice(0,rt)),l=Ke(t),d=[];for(let y=0;y<l;y++){const f=t.shift(),p=Ke(t),S=t.splice(0,p),B=Ke(t),x=new Uint8Array(t.splice(0,B));d.push({programIdIndex:f,accountKeyIndexes:S,data:x})}const k=Ke(t),m=[];for(let y=0;y<k;y++){const f=new H(t.splice(0,rt)),p=Ke(t),S=t.splice(0,p),B=Ke(t),x=t.splice(0,B);m.push({accountKey:f,writableIndexes:S,readonlyIndexes:x})}return new cn({header:i,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:d,addressTableLookups:m})}}const mi={deserializeMessageVersion(r){const e=r[0],t=e&Qr;return t===e?"legacy":t},deserialize:r=>{const e=mi.deserializeMessageVersion(r);if(e==="legacy")return gt.from(r);if(e===0)return cn.deserialize(r);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let vt=function(r){return r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID",r}({});const ml=ee.Buffer.alloc(an).fill(0);class Je{constructor(e){this.keys=void 0,this.programId=void 0,this.data=ee.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class ht{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new Je(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let f=0;f<t.length;f++)if(t[f].programId===void 0)throw new Error(`Transaction instruction index ${f} has undefined program id`);const s=[],o=[];t.forEach(f=>{f.keys.forEach(S=>{o.push({...S})});const p=f.programId.toString();s.includes(p)||s.push(p)}),s.forEach(f=>{o.push({pubkey:new H(f),isSigner:!1,isWritable:!1})});const i=[];o.forEach(f=>{const p=f.pubkey.toString(),S=i.findIndex(B=>B.pubkey.toString()===p);S>-1?(i[S].isWritable=i[S].isWritable||f.isWritable,i[S].isSigner=i[S].isSigner||f.isSigner):i.push(f)}),i.sort(function(f,p){if(f.isSigner!==p.isSigner)return f.isSigner?-1:1;if(f.isWritable!==p.isWritable)return f.isWritable?-1:1;const S={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return f.pubkey.toBase58().localeCompare(p.pubkey.toBase58(),"en",S)});const a=i.findIndex(f=>f.pubkey.equals(n));if(a>-1){const[f]=i.splice(a,1);f.isSigner=!0,f.isWritable=!0,i.unshift(f)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const f of this.signatures){const p=i.findIndex(S=>S.pubkey.equals(f.publicKey));if(p>-1)i[p].isSigner||(i[p].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${f.publicKey.toString()}`)}let c=0,u=0,l=0;const d=[],k=[];i.forEach(({pubkey:f,isSigner:p,isWritable:S})=>{p?(d.push(f.toString()),c+=1,S||(u+=1)):(k.push(f.toString()),S||(l+=1))});const m=d.concat(k),y=t.map(f=>{const{data:p,programId:S}=f;return{programIdIndex:m.indexOf(S.toString()),accounts:f.keys.map(B=>m.indexOf(B.pubkey.toString())),data:Ee.encode(p)}});return y.forEach(f=>{pe(f.programIdIndex>=0),f.accounts.forEach(p=>pe(p>=0))}),new gt({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:m,recentBlockhash:e,instructions:y})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const o=hi(n,s.secretKey);this._addSignature(s.publicKey,Re(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){pe(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=ee.Buffer.from(t)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,t){for(const{signature:n,publicKey:s}of this.signatures)if(n===null){if(t)return!1}else if(!ll(n,e,s.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n&&!this._verifySignatures(s,t))throw new Error("Signature verification failed");return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];He(n,t.length);const s=n.length+t.length*64+e.length,o=ee.Buffer.alloc(s);return pe(t.length<256),ee.Buffer.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(pe(i.length===64,"signature has invalid length"),ee.Buffer.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),pe(o.length<=Wt,`Transaction too large: ${o.length} > ${Wt}`),o}get keys(){return pe(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return pe(this.instructions.length===1),this.instructions[0].programId}get data(){return pe(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=Ke(t);let s=[];for(let o=0;o<n;o++){const i=t.slice(0,an);t=t.slice(an),s.push(Ee.encode(ee.Buffer.from(i)))}return ht.populate(gt.from(t),s)}static populate(e,t=[]){const n=new ht;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==Ee.encode(ml)?null:Ee.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new Je({keys:o,programId:e.accountKeys[s.programIdIndex],data:Ee.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}class vi{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)pe(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let s=0;s<e.header.numRequiredSignatures;s++)n.push(new Uint8Array(an));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();He(t,this.signatures.length);const n=K([fe(t.length,"encodedSignaturesLength"),Ue(pl(),this.signatures.length,"signatures"),fe(e.length,"serializedMessage")]),s=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,o)}static deserialize(e){let t=[...e];const n=[],s=Ke(t);for(let i=0;i<s;i++)n.push(new Uint8Array(t.splice(0,an)));const o=mi.deserialize(new Uint8Array(t));return new vi(o,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of e){const o=n.findIndex(i=>i.equals(s.publicKey));pe(o>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[o]=hi(t,s.secretKey)}}addSignature(e,t){pe(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));pe(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}const vl=160,Sl=64,xl=vl/Sl,kl=1e3/xl;new H("SysvarC1ock11111111111111111111111111111111");new H("SysvarEpochSchedu1e111111111111111111111111");new H("Sysvar1nstructions1111111111111111111111111");const hr=new H("SysvarRecentB1ockHashes11111111111111111111"),$s=new H("SysvarRent111111111111111111111111111111111");new H("SysvarRewards111111111111111111111111111111");new H("SysvarS1otHashes111111111111111111111111111");new H("SysvarS1otHistory11111111111111111111111111");new H("SysvarStakeHistory1111111111111111111111111");function Mt(r){return new Promise(e=>setTimeout(e,r))}function $e(r,e){const t=r.layout.span>=0?r.layout.span:wi(r,e),n=ee.Buffer.alloc(t),s=Object.assign({instruction:r.index},e);return r.layout.encode(s,n),n}const El=Ie("lamportsPerSignature"),Si=K([G("version"),G("state"),re("authorizedPubkey"),re("nonce"),K([El],"feeCalculator")]),js=Si.span;class es{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Si.decode(Re(e),0);return new es({authorizedPubkey:new H(t.authorizedPubkey),nonce:new H(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const _l=r=>{const e=r.decode.bind(r),t=r.encode.bind(r);return{decode:e,encode:t}},Bl=r=>e=>{const t=fe(r,e),{encode:n,decode:s}=_l(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return Yo(ee.Buffer.from(c))},o.encode=(i,a,c)=>{const u=Xo(i,r);return n(u,a,c)},o},Vt=Bl(8),je=Object.freeze({Create:{index:0,layout:K([G("instruction"),Me("lamports"),Me("space"),re("programId")])},Assign:{index:1,layout:K([G("instruction"),re("programId")])},Transfer:{index:2,layout:K([G("instruction"),Vt("lamports")])},CreateWithSeed:{index:3,layout:K([G("instruction"),re("base"),Kt("seed"),Me("lamports"),Me("space"),re("programId")])},AdvanceNonceAccount:{index:4,layout:K([G("instruction")])},WithdrawNonceAccount:{index:5,layout:K([G("instruction"),Me("lamports")])},InitializeNonceAccount:{index:6,layout:K([G("instruction"),re("authorized")])},AuthorizeNonceAccount:{index:7,layout:K([G("instruction"),re("authorized")])},Allocate:{index:8,layout:K([G("instruction"),Me("space")])},AllocateWithSeed:{index:9,layout:K([G("instruction"),re("base"),Kt("seed"),Me("space"),re("programId")])},AssignWithSeed:{index:10,layout:K([G("instruction"),re("base"),Kt("seed"),re("programId")])},TransferWithSeed:{index:11,layout:K([G("instruction"),Vt("lamports"),Kt("seed"),re("programId")])},UpgradeNonceAccount:{index:12,layout:K([G("instruction")])}});class Kn{constructor(){}static createAccount(e){const t=je.Create,n=$e(t,{lamports:e.lamports,space:e.space,programId:Re(e.programId.toBuffer())});return new Je({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const s=je.TransferWithSeed;t=$e(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:Re(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=je.Transfer;t=$e(s,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new Je({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const s=je.AssignWithSeed;t=$e(s,{base:Re(e.basePubkey.toBuffer()),seed:e.seed,programId:Re(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=je.Assign;t=$e(s,{programId:Re(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Je({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=je.CreateWithSeed,n=$e(t,{base:Re(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:Re(e.programId.toBuffer())});let s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new Je({keys:s,programId:this.programId,data:n})}static createNonceAccount(e){const t=new ht;"basePubkey"in e&&"seed"in e?t.add(Kn.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:js,programId:this.programId})):t.add(Kn.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:js,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=je.InitializeNonceAccount,n=$e(t,{authorized:Re(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:$s,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new Je(s)}static nonceAdvance(e){const t=je.AdvanceNonceAccount,n=$e(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new Je(s)}static nonceWithdraw(e){const t=je.WithdrawNonceAccount,n=$e(t,{lamports:e.lamports});return new Je({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:hr,isSigner:!1,isWritable:!1},{pubkey:$s,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=je.AuthorizeNonceAccount,n=$e(t,{authorized:Re(e.newAuthorizedPubkey.toBuffer())});return new Je({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const s=je.AllocateWithSeed;t=$e(s,{base:Re(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:Re(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=je.Allocate;t=$e(s,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Je({keys:n,programId:this.programId,data:t})}}Kn.programId=new H("11111111111111111111111111111111");new H("BPFLoader2111111111111111111111111111111111");function Al(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Il=Object.prototype.toString,Rl=Object.keys||function(r){var e=[];for(var t in r)e.push(t);return e};function nn(r,e){var t,n,s,o,i,a,c;if(r===!0)return"true";if(r===!1)return"false";switch(typeof r){case"object":if(r===null)return null;if(r.toJSON&&typeof r.toJSON=="function")return nn(r.toJSON(),e);if(c=Il.call(r),c==="[object Array]"){for(s="[",n=r.length-1,t=0;t<n;t++)s+=nn(r[t],!0)+",";return n>-1&&(s+=nn(r[t],!0)),s+"]"}else if(c==="[object Object]"){for(o=Rl(r).sort(),n=o.length,s="",t=0;t<n;)i=o[t],a=nn(r[i],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(i)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(r);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}var Tl=function(r){var e=nn(r,!1);if(e!==void 0)return""+e},Gs=Al(Tl);const en=32;function pr(r){let e=0;for(;r>1;)r/=2,e++;return e}function Ll(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}class Cl{constructor(e,t,n,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=pr(Ll(e+en+1))-pr(en)-1,n=this.getSlotsInEpoch(t),s=e-(n-en);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*en:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+pr(en)):this.slotsPerEpoch}}class Vs extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class W extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var Pl=globalThis.fetch;class Ol extends Ju{constructor(e,t,n){const s=o=>{const i=Qu(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function Ul(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${r.index}`);return t}const Zs=56;class Ys{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Ul(Nl,e),n=e.length-Zs;pe(n>=0,"lookup table is invalid"),pe(n%32===0,"lookup table is invalid");const s=n/32,{addresses:o}=K([Ue(re(),s,"addresses")]).decode(e.slice(Zs));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new H(t.authority[0]):void 0,addresses:o.map(i=>new H(i))}}}const Nl={index:1,layout:K([G("typeIndex"),Vt("deactivationSlot"),Ie("lastExtendedSlot"),se("lastExtendedStartIndex"),se(),Ue(re(),Lt(se(),-1),"authority")])},ql=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Fl(r){const e=r.match(ql);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);const[t,n,s,o]=e,i=r.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}const Se=pn(Vr(H),q(),r=>new H(r)),xi=Zr([q(),ye("base64")]),ts=pn(Vr(ee.Buffer),xi,r=>ee.Buffer.from(r[0],"base64")),zl=30*1e3;function Dl(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function he(r){let e,t;if(typeof r=="string")e=r;else if(r){const{commitment:n,...s}=r;e=n,t=s}return{commitment:e,config:t}}function ki(r){return ze([T({jsonrpc:ye("2.0"),id:q(),result:r}),T({jsonrpc:ye("2.0"),id:q(),error:T({code:hn(),message:q(),data:X(nu())})})])}const Ml=ki(hn());function ne(r){return pn(ki(r),Ml,e=>"error"in e?e:{...e,result:F(e.result,r)})}function me(r){return ne(T({context:T({slot:b()}),value:r}))}function Jn(r){return T({context:T({slot:b()}),value:r})}function gr(r,e){return r===0?new cn({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new H(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Ee.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new gt(e)}const Kl=T({foundation:b(),foundationTerm:b(),initial:b(),taper:b(),terminal:b()}),Hl=ne(D(z(T({epoch:b(),effectiveSlot:b(),amount:b(),postBalance:b(),commission:X(z(b()))})))),Wl=D(T({slot:b(),prioritizationFee:b()})),$l=T({total:b(),validator:b(),foundation:b(),epoch:b()}),jl=T({epoch:b(),slotIndex:b(),slotsInEpoch:b(),absoluteSlot:b(),blockHeight:X(b()),transactionCount:X(b())}),Gl=T({slotsPerEpoch:b(),leaderScheduleSlotOffset:b(),warmup:it(),firstNormalEpoch:b(),firstNormalSlot:b()}),Vl=Qo(q(),D(b())),Nt=z(ze([T({}),q()])),Zl=T({err:Nt}),Yl=ye("receivedSignature"),Xl=T({"solana-core":q(),"feature-set":X(b())}),Xs=me(T({err:z(ze([T({}),q()])),logs:z(D(q())),accounts:X(z(D(z(T({executable:it(),owner:q(),lamports:b(),data:D(q()),rentEpoch:X(b())}))))),unitsConsumed:X(b()),returnData:X(z(T({programId:q(),data:Zr([q(),ye("base64")])})))})),Jl=me(T({byIdentity:Qo(q(),D(b())),range:T({firstSlot:b(),lastSlot:b()})}));function Ql(r,e,t,n,s,o){const i=t||Pl;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(l,d)=>{const k=await new Promise((m,y)=>{try{n(l,d,(f,p)=>m([f,p]))}catch(f){y(f)}});return await i(...k)}),new Tu(async(l,d)=>{const k={method:"POST",body:l,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},td)};try{let m=5,y,f=500;for(;c?y=await c(r,k):y=await i(r,k),!(y.status!==429||s===!0||(m-=1,m===0));)console.log(`Server responded with ${y.status} ${y.statusText}.  Retrying after ${f}ms delay...`),await Mt(f),f*=2;const p=await y.text();y.ok?d(null,p):d(new Error(`${y.status} ${y.statusText}: ${p}`))}catch(m){m instanceof Error&&d(m)}},{})}function ef(r){return(e,t)=>new Promise((n,s)=>{r.request(e,t,(o,i)=>{if(o){s(o);return}n(i)})})}function tf(r){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(o=>r.request(o.methodName,o.args));r.request(s,(o,i)=>{if(o){n(o);return}t(i)})})}const nf=ne(Kl),rf=ne($l),sf=ne(Wl),of=ne(jl),af=ne(Gl),cf=ne(Vl),uf=ne(b()),lf=me(T({total:b(),circulating:b(),nonCirculating:b(),nonCirculatingAccounts:D(Se)})),Ar=T({amount:q(),uiAmount:z(b()),decimals:b(),uiAmountString:X(q())}),ff=me(D(T({address:Se,amount:q(),uiAmount:z(b()),decimals:b(),uiAmountString:X(q())}))),df=me(D(T({pubkey:Se,account:T({executable:it(),owner:Se,lamports:b(),data:ts,rentEpoch:b()})}))),Ir=T({program:q(),parsed:hn(),space:b()}),hf=me(D(T({pubkey:Se,account:T({executable:it(),owner:Se,lamports:b(),data:Ir,rentEpoch:b()})}))),pf=me(D(T({lamports:b(),address:Se}))),un=T({executable:it(),owner:Se,lamports:b(),data:ts,rentEpoch:b()}),gf=T({pubkey:Se,account:un}),yf=pn(ze([Vr(ee.Buffer),Ir]),ze([xi,Ir]),r=>Array.isArray(r)?F(r,ts):r),Rr=T({executable:it(),owner:Se,lamports:b(),data:yf,rentEpoch:b()}),bf=T({pubkey:Se,account:Rr}),wf=T({state:ze([ye("active"),ye("inactive"),ye("activating"),ye("deactivating")]),active:b(),inactive:b()}),mf=ne(D(T({signature:q(),slot:b(),err:Nt,memo:z(q()),blockTime:X(z(b()))}))),vf=ne(D(T({signature:q(),slot:b(),err:Nt,memo:z(q()),blockTime:X(z(b()))}))),Sf=T({subscription:b(),result:Jn(un)}),xf=T({pubkey:Se,account:un}),kf=T({subscription:b(),result:Jn(xf)}),Ef=T({parent:b(),slot:b(),root:b()}),_f=T({subscription:b(),result:Ef}),Bf=ze([T({type:ze([ye("firstShredReceived"),ye("completed"),ye("optimisticConfirmation"),ye("root")]),slot:b(),timestamp:b()}),T({type:ye("createdBank"),parent:b(),slot:b(),timestamp:b()}),T({type:ye("frozen"),slot:b(),timestamp:b(),stats:T({numTransactionEntries:b(),numSuccessfulTransactions:b(),numFailedTransactions:b(),maxTransactionsPerEntry:b()})}),T({type:ye("dead"),slot:b(),timestamp:b(),err:q()})]),Af=T({subscription:b(),result:Bf}),If=T({subscription:b(),result:Jn(ze([Zl,Yl]))}),Rf=T({subscription:b(),result:b()}),Tf=T({pubkey:q(),gossip:z(q()),tpu:z(q()),rpc:z(q()),version:z(q())}),Js=T({votePubkey:q(),nodePubkey:q(),activatedStake:b(),epochVoteAccount:it(),epochCredits:D(Zr([b(),b(),b()])),commission:b(),lastVote:b(),rootSlot:z(b())}),Lf=ne(T({current:D(Js),delinquent:D(Js)})),Cf=ze([ye("processed"),ye("confirmed"),ye("finalized")]),Pf=T({slot:b(),confirmations:z(b()),err:Nt,confirmationStatus:X(Cf)}),Of=me(D(z(Pf))),Uf=ne(b()),Ei=T({accountKey:Se,writableIndexes:D(b()),readonlyIndexes:D(b())}),ns=T({signatures:D(q()),message:T({accountKeys:D(q()),header:T({numRequiredSignatures:b(),numReadonlySignedAccounts:b(),numReadonlyUnsignedAccounts:b()}),instructions:D(T({accounts:D(b()),data:q(),programIdIndex:b()})),recentBlockhash:q(),addressTableLookups:X(D(Ei))})}),_i=T({pubkey:Se,signer:it(),writable:it(),source:X(ze([ye("transaction"),ye("lookupTable")]))}),Bi=T({accountKeys:D(_i),signatures:D(q())}),Ai=T({parsed:hn(),program:q(),programId:Se}),Ii=T({accounts:D(Se),data:q(),programId:Se}),Nf=ze([Ii,Ai]),qf=ze([T({parsed:hn(),program:q(),programId:q()}),T({accounts:D(q()),data:q(),programId:q()})]),Ri=pn(Nf,qf,r=>"accounts"in r?F(r,Ii):F(r,Ai)),Ti=T({signatures:D(q()),message:T({accountKeys:D(_i),instructions:D(Ri),recentBlockhash:q(),addressTableLookups:X(z(D(Ei)))})}),Hn=T({accountIndex:b(),mint:q(),owner:X(q()),uiTokenAmount:Ar}),Li=T({writable:D(Se),readonly:D(Se)}),Qn=T({err:Nt,fee:b(),innerInstructions:X(z(D(T({index:b(),instructions:D(T({accounts:D(b()),data:q(),programIdIndex:b()}))})))),preBalances:D(b()),postBalances:D(b()),logMessages:X(z(D(q()))),preTokenBalances:X(z(D(Hn))),postTokenBalances:X(z(D(Hn))),loadedAddresses:X(Li),computeUnitsConsumed:X(b())}),rs=T({err:Nt,fee:b(),innerInstructions:X(z(D(T({index:b(),instructions:D(Ri)})))),preBalances:D(b()),postBalances:D(b()),logMessages:X(z(D(q()))),preTokenBalances:X(z(D(Hn))),postTokenBalances:X(z(D(Hn))),loadedAddresses:X(Li),computeUnitsConsumed:X(b())}),Jt=ze([ye(0),ye("legacy")]),qt=T({pubkey:q(),lamports:b(),postBalance:z(b()),rewardType:z(q()),commission:X(z(b()))}),Ff=ne(z(T({blockhash:q(),previousBlockhash:q(),parentSlot:b(),transactions:D(T({transaction:ns,meta:z(Qn),version:X(Jt)})),rewards:X(D(qt)),blockTime:z(b()),blockHeight:z(b())}))),zf=ne(z(T({blockhash:q(),previousBlockhash:q(),parentSlot:b(),rewards:X(D(qt)),blockTime:z(b()),blockHeight:z(b())}))),Df=ne(z(T({blockhash:q(),previousBlockhash:q(),parentSlot:b(),transactions:D(T({transaction:Bi,meta:z(Qn),version:X(Jt)})),rewards:X(D(qt)),blockTime:z(b()),blockHeight:z(b())}))),Mf=ne(z(T({blockhash:q(),previousBlockhash:q(),parentSlot:b(),transactions:D(T({transaction:Ti,meta:z(rs),version:X(Jt)})),rewards:X(D(qt)),blockTime:z(b()),blockHeight:z(b())}))),Kf=ne(z(T({blockhash:q(),previousBlockhash:q(),parentSlot:b(),transactions:D(T({transaction:Bi,meta:z(rs),version:X(Jt)})),rewards:X(D(qt)),blockTime:z(b()),blockHeight:z(b())}))),Hf=ne(z(T({blockhash:q(),previousBlockhash:q(),parentSlot:b(),rewards:X(D(qt)),blockTime:z(b()),blockHeight:z(b())}))),Wf=ne(z(T({blockhash:q(),previousBlockhash:q(),parentSlot:b(),transactions:D(T({transaction:ns,meta:z(Qn)})),rewards:X(D(qt)),blockTime:z(b())}))),Qs=ne(z(T({blockhash:q(),previousBlockhash:q(),parentSlot:b(),signatures:D(q()),blockTime:z(b())}))),yr=ne(z(T({slot:b(),meta:z(Qn),blockTime:X(z(b())),transaction:ns,version:X(Jt)}))),Sn=ne(z(T({slot:b(),transaction:Ti,meta:z(rs),blockTime:X(z(b())),version:X(Jt)}))),$f=me(T({blockhash:q(),feeCalculator:T({lamportsPerSignature:b()})})),jf=me(T({blockhash:q(),lastValidBlockHeight:b()})),Gf=me(it()),Vf=T({slot:b(),numTransactions:b(),numSlots:b(),samplePeriodSecs:b()}),Zf=ne(D(Vf)),Yf=me(z(T({feeCalculator:T({lamportsPerSignature:b()})}))),Xf=ne(q()),Jf=ne(q()),Qf=T({err:Nt,logs:D(q()),signature:q()}),ed=T({result:Jn(Qf),subscription:b()}),td={"solana-client":"js/0.0.0-development"};class nd{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async l=>{const{commitment:d,config:k}=he(l),m=this._buildArgs([],d,void 0,k),y=Gs(m);return u[y]=u[y]??(async()=>{try{const f=await this._rpcRequest("getBlockHeight",m),p=F(f,ne(b()));if("error"in p)throw new W(p.error,"failed to get block height information");return p.result}finally{delete u[y]}})(),await u[y]}})();let n,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=Dl(e),this._rpcWsEndpoint=n||Fl(e),this._rpcClient=Ql(e,s,o,i,a,c),this._rpcRequest=ef(this._rpcClient),this._rpcBatchRequest=tf(this._rpcClient),this._rpcWebSocket=new Ol(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgs([e.toBase58()],n,void 0,s),i=await this._rpcRequest("getBalance",o),a=F(i,me(b()));if("error"in a)throw new W(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=F(t,ne(z(b())));if("error"in n)throw new W(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=F(e,ne(b()));if("error"in t)throw new W(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=F(e,uf);if("error"in t)throw new W(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=F(n,lf);if("error"in s)throw new W(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),o=F(s,me(Ar));if("error"in o)throw new W(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),o=F(s,me(Ar));if("error"in o)throw new W(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:o}=he(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=F(c,df);if("error"in u)throw new W(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=F(i,hf);if("error"in a)throw new W(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),o=F(s,pf);if("error"in o)throw new W(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),o=F(s,ff);if("error"in o)throw new W(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgs([e.toBase58()],n,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=F(i,me(z(un)));if("error"in a)throw new W(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=F(i,me(z(Rr)));if("error"in a)throw new W(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=he(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=F(a,me(D(z(Rr))));if("error"in c)throw new W(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=he(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=F(a,me(D(z(un))));if("error"in c)throw new W(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:o}=he(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:n??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=F(a,ne(wf));if("error"in c)throw new W(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=he(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],n,o||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),u=D(gf),l=i.withContext===!0?F(c,me(u)):F(c,ne(u));if("error"in l)throw new W(l.error,`failed to get accounts owned by program ${e.toBase58()}`);return l.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=F(i,ne(D(bf)));if("error"in a)throw new W(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var o;let n;if(typeof e=="string")n=e;else{const i=e;if((o=i.abortSignal)!=null&&o.aborted)return Promise.reject(i.abortSignal.reason);n=i.signature}let s;try{s=Ee.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return pe(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,o=!1;const i=new Promise((c,u)=>{try{n=this.onSignature(t,(d,k)=>{n=void 0;const m={context:k,value:d};c({__type:vt.PROCESSED,response:m})},e);const l=new Promise(d=>{n==null?d():s=this._onSubscriptionStateChange(n,k=>{k==="subscribed"&&d()})});(async()=>{if(await l,o)return;const d=await this.getSignatureStatus(t);if(o||d==null)return;const{context:k,value:m}=d;if(m!=null)if(m!=null&&m.err)u(m.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(m.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(m.confirmationStatus==="processed"||m.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:vt.PROCESSED,response:{context:k,value:m}})}})()}catch(l){u(l)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let o=!1;const i=new Promise(d=>{const k=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let m=await k();if(!o){for(;m<=n;)if(await Mt(1e3),o||(m=await k(),o))return;d({__type:vt.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),u=this.getCancellationPromise(t);let l;try{const d=await Promise.race([u,c,i]);if(d.__type===vt.PROCESSED)l=d.response;else throw new yi(s)}finally{o=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(m=>{let y=o,f=null;const p=async()=>{try{const{context:S,value:B}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return f=S.slot,B==null?void 0:B.nonce}catch{return y}};(async()=>{if(y=await p(),!a)for(;;){if(o!==y){m({__type:vt.NONCE_INVALID,slotInWhichNonceDidAdvance:f});return}if(await Mt(2e3),a||(y=await p(),a))return}})()}),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),d=this.getCancellationPromise(t);let k;try{const m=await Promise.race([d,l,c]);if(m.__type===vt.PROCESSED)k=m.response;else{let y;for(;;){const f=await this.getSignatureStatus(i);if(f==null)break;if(f.context.slot<(m.slotInWhichNonceDidAdvance??n)){await Mt(400);continue}y=f;break}if(y!=null&&y.value){const f=e||"finalized",{confirmationStatus:p}=y.value;switch(f){case"processed":case"recent":if(p!=="processed"&&p!=="confirmed"&&p!=="finalized")throw new tn(i);break;case"confirmed":case"single":case"singleGossip":if(p!=="confirmed"&&p!=="finalized")throw new tn(i);break;case"finalized":case"max":case"root":if(p!=="finalized")throw new tn(i);break;default:(S=>{})(f)}k={context:y.context,value:{err:y.value.err}}}else throw new tn(i)}}finally{a=!0,u()}return k}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:vt.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===vt.PROCESSED)a=c.response;else throw new bi(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=F(e,ne(D(Tf)));if("error"in t)throw new W(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=F(n,Lf);if("error"in s)throw new W(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=he(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",s),i=F(o,ne(b()));if("error"in i)throw new W(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=he(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",s),i=F(o,ne(q()));if("error"in i)throw new W(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),o=F(s,ne(D(Se)));if("error"in o)throw new W(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);pe(s.length===1);const o=s[0];return{context:n,value:o}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),o=F(s,Of);if("error"in o)throw new W(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:n}=he(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",s),i=F(o,ne(b()));if("error"in i)throw new W(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=F(n,nf);if("error"in s)throw new W(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:o}=he(n),i=this._buildArgs([e.map(u=>u.toBase58())],s,void 0,{...o,epoch:t??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=F(a,Hl);if("error"in c)throw new W(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=F(e,rf);if("error"in t)throw new W(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=he(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",s),i=F(o,of);if("error"in i)throw new W(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=F(e,af);if("error"in t)throw new W(t.error,"failed to get epoch schedule");const n=t.result;return new Cl(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=F(e,cf);if("error"in t)throw new W(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=F(s,Uf);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=F(n,$f);if("error"in s)throw new W(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=F(t,Zf);if("error"in n)throw new W(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=F(s,Yf);if("error"in o)throw new W(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=Re(e.serialize()).toString("base64"),s=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",s),i=F(o,me(z(b())));if("error"in i)throw new W(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),n=t!=null&&t.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),o=F(s,sf);if("error"in o)throw new W(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=he(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",s),i=F(o,jf);if("error"in i)throw new W(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgs([e],n,void 0,s),i=await this._rpcRequest("isBlockhashValid",o),a=F(i,Gf);if("error"in a)throw new W(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=F(e,ne(Xl));if("error"in t)throw new W(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=F(e,ne(q()));if("error"in t)throw new W(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=F(i,Df);if("error"in a)throw a.error;return a.result}case"none":{const a=F(i,zf);if("error"in a)throw a.error;return a.result}default:{const a=F(i,Ff);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:l,version:d})=>({meta:l,transaction:{...u,message:gr(d,u.message)},version:d}))}:null}}}catch(a){throw new W(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=F(i,Kf);if("error"in a)throw a.error;return a.result}case"none":{const a=F(i,Hf);if("error"in a)throw a.error;return a.result}default:{const a=F(i,Mf);if("error"in a)throw a.error;return a.result}}}catch(a){throw new W(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=F(o,Jl);if("error"in i)throw new W(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getTransaction",o),a=F(i,yr);if("error"in a)throw new W(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:gr(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=he(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=F(i,Sn);if("error"in a)throw new W(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=he(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=F(c,Sn);if("error"in u)throw new W(u.error,"failed to get transactions");return u.result})}async getTransactions(e,t){const{commitment:n,config:s}=he(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(o)).map(c=>{const u=F(c,yr);if("error"in u)throw new W(u.error,"failed to get transactions");const l=u.result;return l&&{...l,transaction:{...l.transaction,message:gr(l.version,l.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),o=F(s,Wf);if("error"in o)throw new W(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:u})=>{const l=new gt(c.message);return{meta:u,transaction:{...c,message:l}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:ht.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",s),i=F(o,ne(D(b())));if("error"in i)throw new W(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),o=F(s,Qs);if("error"in o)throw new W(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),o=F(s,Qs);if("error"in o)throw new W(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),o=F(s,yr);if("error"in o)throw new W(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new gt(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:ht.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),o=F(s,Sn);if("error"in o)throw new W(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=F(i,Sn);if("error"in a)throw new W(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=F(o,mf);if("error"in i)throw new W(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=F(o,vf);if("error"in i)throw new W(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new Ys({key:e,state:Ys.deserialize(s.data)})),{context:n,value:o}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=es.fromAccountData(s.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=F(n,Xf);if("error"in s)throw new W(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await Mt(100);const n=Date.now()-this._blockhashInfo.lastFetch>=zl;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await Mt(kl/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=he(e),s=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=F(o,me(b()));if("error"in i)throw new W(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const f=e.serialize(),p=ee.Buffer.from(f).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const S=t||{};S.encoding="base64","commitment"in S||(S.commitment=this.commitment);const B=[p,S],x=await this._rpcRequest("simulateTransaction",B),_=F(x,Xs);if("error"in _)throw new Error("failed to simulate transaction: "+_.error.message);return _.result}let s;if(e instanceof ht){let y=e;s=new ht,s.feePayer=y.feePayer,s.instructions=e.instructions,s.nonceInfo=y.nonceInfo,s.signatures=y.signatures}else s=ht.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let y=this._disableBlockhashCaching;for(;;){const f=await this._blockhashWithExpiryBlockHeight(y);if(s.lastValidBlockHeight=f.lastValidBlockHeight,s.recentBlockhash=f.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const p=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(p)&&!this._blockhashInfo.transactionSignatures.includes(p)){this._blockhashInfo.simulatedSignatures.push(p);break}else y=!0}}const i=s._compile(),a=i.serialize(),u=s._serialize(a).toString("base64"),l={encoding:"base64",commitment:this.commitment};if(n){const y=(Array.isArray(n)?n:i.nonProgramIds()).map(f=>f.toBase58());l.accounts={encoding:"base64",addresses:y}}o&&(l.sigVerify=!0);const d=[u,l],k=await this._rpcRequest("simulateTransaction",d),m=F(k,Xs);if("error"in m){let y;if("data"in m.error&&(y=m.error.data.logs,y&&Array.isArray(y))){const f=`
    `,p=f+y.join(f);console.error(m.error.message,p)}throw new Vs("failed to simulate transaction: "+m.error.message,y)}return m.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){const n=Re(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,o=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),o&&(n.preflightCommitment=o);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=F(a,Jf);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new Vs("failed to send transaction: "+c.error.message,u)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var s;const n=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const o=this._subscriptionStateChangeCallbacksByHash[e];o&&o.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(o=this._subscriptionStateChangeCallbacksByHash)[n]||(o[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=F(e,Sf);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=Gs([e.method,t],!0),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[s];pe(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=F(e,kf);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const o=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=F(e,ed);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=F(e,_f);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=F(e,Af);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const o=t||this._commitment;if(o||n||s){let i={};n&&(i.encoding=n),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=F(e,If);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,n){const{commitment:s,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,u)=>{t(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=F(e,Rf);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}Object.freeze({CreateLookupTable:{index:0,layout:K([G("instruction"),Vt("recentSlot"),se("bumpSeed")])},FreezeLookupTable:{index:1,layout:K([G("instruction")])},ExtendLookupTable:{index:2,layout:K([G("instruction"),Vt(),Ue(re(),Lt(G(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:K([G("instruction")])},CloseLookupTable:{index:4,layout:K([G("instruction")])}});new H("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:K([se("instruction"),G("units"),G("additionalFee")])},RequestHeapFrame:{index:1,layout:K([se("instruction"),G("bytes")])},SetComputeUnitLimit:{index:2,layout:K([se("instruction"),G("units")])},SetComputeUnitPrice:{index:3,layout:K([se("instruction"),Vt("microLamports")])}});new H("ComputeBudget111111111111111111111111111111");K([se("numSignatures"),se("padding"),Ve("signatureOffset"),Ve("signatureInstructionIndex"),Ve("publicKeyOffset"),Ve("publicKeyInstructionIndex"),Ve("messageDataOffset"),Ve("messageDataSize"),Ve("messageInstructionIndex")]);new H("Ed25519SigVerify111111111111111111111111111");Jr.utils.isValidPrivateKey;Jr.getPublicKey;K([se("numSignatures"),Ve("signatureOffset"),se("signatureInstructionIndex"),Ve("ethAddressOffset"),se("ethAddressInstructionIndex"),Ve("messageDataOffset"),Ve("messageDataSize"),se("messageInstructionIndex"),fe(20,"ethAddress"),fe(64,"signature"),se("recoveryId")]);new H("KeccakSecp256k11111111111111111111111111111");var Ci;new H("StakeConfig11111111111111111111111111111111");class Pi{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}Ci=Pi;Pi.default=new Ci(0,0,H.default);Object.freeze({Initialize:{index:0,layout:K([G("instruction"),gl(),yl()])},Authorize:{index:1,layout:K([G("instruction"),re("newAuthorized"),G("stakeAuthorizationType")])},Delegate:{index:2,layout:K([G("instruction")])},Split:{index:3,layout:K([G("instruction"),Me("lamports")])},Withdraw:{index:4,layout:K([G("instruction"),Me("lamports")])},Deactivate:{index:5,layout:K([G("instruction")])},Merge:{index:7,layout:K([G("instruction")])},AuthorizeWithSeed:{index:8,layout:K([G("instruction"),re("newAuthorized"),G("stakeAuthorizationType"),Kt("authoritySeed"),re("authorityOwner")])}});new H("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:K([G("instruction"),bl()])},Authorize:{index:1,layout:K([G("instruction"),re("newAuthorized"),G("voteAuthorizationType")])},Withdraw:{index:3,layout:K([G("instruction"),Me("lamports")])},AuthorizeWithSeed:{index:10,layout:K([G("instruction"),wl()])}});new H("Vote111111111111111111111111111111111111111");new H("Va1idator1nfo111111111111111111111111111111");T({name:q(),website:X(q()),details:X(q()),keybaseUsername:X(q())});new H("Vote111111111111111111111111111111111111111");K([re("nodePubkey"),re("authorizedWithdrawer"),se("commission"),Ie(),Ue(K([Ie("slot"),G("confirmationCount")]),Lt(G(),-8),"votes"),se("rootSlotValid"),Ie("rootSlot"),Ie(),Ue(K([Ie("epoch"),re("authorizedVoter")]),Lt(G(),-8),"authorizedVoters"),K([Ue(K([re("authorizedPubkey"),Ie("epochOfLastAuthorizedSwitch"),Ie("targetEpoch")]),32,"buf"),Ie("idx"),se("isEmpty")],"priorVoters"),Ie(),Ue(K([Ie("epoch"),Ie("credits"),Ie("prevCredits")]),Lt(G(),-8),"epochCredits"),K([Ie("slot"),Ie("timestamp")],"lastTimestamp")]);const Oi=new H("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new H("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const Ui=new H("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new H("So11111111111111111111111111111111111111112");new H("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");const ss=r=>{const e=r.decode.bind(r),t=r.encode.bind(r);return{decode:e,encode:t}},rd=r=>e=>{const t=fe(r,e),{encode:n,decode:s}=ss(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return Yo(ee.Buffer.from(c))},o.encode=(i,a,c)=>{const u=Xo(i,r);return n(u,a,c)},o},sd=rd(8),od=r=>{const e=se(r),{encode:t,decode:n}=ss(e),s=e;return s.decode=(o,i)=>!!n(o,i),s.encode=(o,i,a)=>{const c=Number(o);return t(c,i,a)},s},eo=r=>{const e=fe(32,r),{encode:t,decode:n}=ss(e),s=e;return s.decode=(o,i)=>{const a=n(o,i);return new H(a)},s.encode=(o,i,a)=>{const c=o.toBuffer();return t(c,i,a)},s};class id extends Error{constructor(e){super(e)}}class Ni extends id{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}const ad=K([G("mintAuthorityOption"),eo("mintAuthority"),sd("supply"),se("decimals"),od("isInitialized"),G("freezeAuthorityOption"),eo("freezeAuthority")]);ad.span;async function cd(r,e,t=!1,n=Oi,s=Ui){if(!t&&!H.isOnCurve(e.toBuffer()))throw new Ni;const[o]=await H.findProgramAddress([e.toBuffer(),n.toBuffer(),r.toBuffer()],s);return o}function _d(r,e,t=!1,n=Oi,s=Ui){if(!t&&!H.isOnCurve(e.toBuffer()))throw new Ni;const[o]=H.findProgramAddressSync([e.toBuffer(),n.toBuffer(),r.toBuffer()],s);return o}class ud{constructor(e){_t(this,"network");_t(this,"provider");_t(this,"nativeAssetAddress");_t(this,"nativeAssetDecimals");var t,n;this.service=e,this.network=this.service.configService.network.key,this.provider=this.service.rpcProviderService,this.nativeAssetAddress=((t=this.service.configService.network.solanaNativeAsset)==null?void 0:t.address_spl)??"",this.nativeAssetDecimals=((n=this.service.configService.network.solanaNativeAsset)==null?void 0:n.decimals)??9}async get(e,t){if(!t)return{};const n=[];return t.forEach(i=>{const a=this.fetchBalances(e,i);n.push(a)}),(await Promise.all(n)).filter(i=>Object.keys(i).length>0).reduce((i,a)=>Object.assign(i,a))}async fetchBalances(e,t){if(!t)return{};try{const n={};if(t.toLowerCase()===this.nativeAssetAddress.toLowerCase())return n[t]=await this.fetchNativeBalance(e),{...n};{const s=new H(t),o=new H(e),i=await cd(s,o),a=await this.provider.getTokenAccountBalance(i);return this.associateBalances(a,t)}}catch{return console.error("Could not fetch a balance for:",t),{[t]:"0"}}}async fetchNativeBalance(e){const t=new H(e),n=await this.provider.getBalance(t);return Qi(n.toString(),this.nativeAssetDecimals)}associateBalances(e,t){return{[t]:(Number(e.value.amount)/Math.pow(10,e.value.decimals)).toString()}}}const ld=Tr.network.solanaRpc;class fd{constructor(e=ud,t=new nd(ld,{commitment:"confirmed"}),n=Tr){_t(this,"connection");_t(this,"balances");this.balancesConcernClass=e,this.rpcProviderService=t,this.configService=n,this.connection=this.rpcProviderService,this.balances=new e(this)}}function dd({tokens:r,isEnabled:e=so(!0)}){const{isConnected:t,publicKeyTrimmed:n}=aa(),{networkId:s}=Vi(),o=nt(()=>t.value&&e.value),i=nt(()=>Object.keys(r.value).filter(d=>!!r.value[d].address_spl).map(d=>r.value[d].address_spl)),a=nt(()=>Object.keys(r.value)),c=wr(ea.Account.Balances(s,n,a)),u=async()=>(console.log("Fetching",i.value.length,"solana balances"),await new fd().balances.get(n.value,i.value)),l=wr({enabled:o,keepPreviousData:!0,refetchOnWindowFocus:!1});return ta(c,u,l)}const hd=(r,e)=>{const{networkConfig:t}=ra(),{isWalletReady:n}=sa(),{bridgeTokenListMap:s}=e,o=so(!1),i={...t.nativeAsset,chainId:t.chainId},a=wr({loading:!0,injectedTokens:{},spenders:hs.compact([t.addresses.vault,t.tokens.Addresses.wstETH,Tr.network.addresses.veBAL]),injectedPrices:{}}),c=nt(()=>I(s.value)),u=nt(()=>({[t.nativeAsset.address]:i,...c.value,...a.injectedTokens})),l=nt(()=>V(Zi.Addresses.wNativeAsset)),{data:d,isSuccess:k,isInitialLoading:m,isRefetching:y,isError:f,refetch:p}=dd({tokens:u,isEnabled:o}),S=nt(()=>d.value?d.value:{}),B=nt(()=>n.value&&(y.value||m.value)),x=nt(()=>k.value),_=nt(()=>B.value);function I(Q){return Object.keys(Q).length===0?{}:[...Object.values(Q)].map(C=>C.tokens).flat().reduce((C,h)=>{const g=Ft(h.address);return C[g]||h.chainId!==t.chainId||(C[g]=h),C},{})}async function v(Q,{excluded:P=[],subset:N=[]}){let $=N.length>0?j(N):u.value;if(!Q)return R($,P);$=N.length>0?$:c.value;const C=ps(Q);if(Yi(C)){const h=Ft(C),g=$[h];return{[h]:g}}else{const g=Object.entries($).filter(([,E])=>{var L,U,O;return((L=E.name)==null?void 0:L.toLowerCase().includes(Q.toLowerCase()))||((U=E.symbol)==null?void 0:U.toLowerCase().includes(Q.toLowerCase()))||((O=E.address_spl)==null?void 0:O.toLowerCase().includes(Q.toLowerCase()))});return R(Object.fromEntries(g),P)}}function R(Q,P){return Object.keys(Q).filter(N=>!Xi(P,N)).reduce((N,$)=>(N[$]=Q[$],N),{})}function A(Q,P){try{return P?yn(S.value,Q)||"0":yn(S.value,Ft(Q))||"0"}catch{return"0"}}function M(Q){return Number(yn(S.value,Ft(Q))||"0")>0}function j(Q){return hs.pick(u.value,Q.map(Ft))}function V(Q){return Q=ps(Q),yn(u.value,Ft(Q))}function ie(Q,P=!1){let N;const $=A(Q)||"0",C=Ji($);return Q===i.address&&!P?N=C.gt(i.minTransactionBuffer)?C.minus(i.minTransactionBuffer).toString():$.toString():N=$,N}function ae(Q){return gs(Q,i.address)||gs(Q,l.value.address)}return ua(async()=>{o.value=!0,a.loading=!1}),{...la(a),nativeAsset:i,tokens:u,wrappedNativeAsset:l,balances:S,dynamicDataLoaded:x,dynamicDataLoading:_,bridgeBalancesQueryError:f,refetchBridgeBalances:p,searchTokens:v,hasBalance:M,bridgeBalanceFor:A,getTokens:j,getToken:V,getMaxBridgeBalanceFor:ie,isWethOrEth:ae}},qi=Symbol(oa.Providers.BridgeTokens);function Bd(r,e){const t=hd(r,e);return ca(qi,t),t}const Ad=()=>na(qi);export{Ui as A,fd as B,H as P,Kn as S,Je as T,vi as V,se as a,Bd as b,sd as c,Oi as d,ht as e,Ee as f,_d as g,$s as h,K as s,Ad as u};
//# sourceMappingURL=bridge-tokens.provider-266bc0cb.js.map
