var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { WalletError, WalletReadyState, WalletNotConnectedError, WalletNotReadyError } from "@solana/wallet-adapter-base";
import { useLocalStorage, onClickOutside, onKeyStroke, useScrollLock, useClipboard } from "@vueuse/core";
import { shallowRef, ref, computed, watchEffect, defineComponent, toRefs, openBlock, createElementBlock, createCommentVNode, resolveComponent, renderSlot, normalizeProps, guardReactiveProps, createElementVNode, createBlock, toDisplayString, watch, nextTick, Fragment, normalizeClass, Teleport, withModifiers, renderList, createVNode, createTextVNode, withCtx, normalizeStyle } from "vue";
class WalletNotSelectedError extends WalletError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "WalletNotSelectedError");
  }
}
class WalletNotInitializedError extends WalletError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "WalletNotSelectedError");
  }
}
const createWalletStore = ({
  wallets: initialAdapters = [],
  autoConnect: initialAutoConnect = false,
  onError = (error) => console.error(error),
  localStorageKey = "walletName"
}) => {
  const adapters = shallowRef(initialAdapters);
  const autoConnect = ref(initialAutoConnect);
  const name = useLocalStorage(
    localStorageKey,
    null
  );
  const wallet = shallowRef(null);
  const publicKey = ref(null);
  const readyState = ref(WalletReadyState.Unsupported);
  const connected = ref(false);
  const connecting = ref(false);
  const disconnecting = ref(false);
  const unloadingWindow = ref(false);
  const ready = computed(
    () => readyState.value === WalletReadyState.Installed || readyState.value === WalletReadyState.Loadable
  );
  const wallets = shallowRef([]);
  watchEffect(() => {
    wallets.value = adapters.value.map((newAdapter) => ({
      adapter: newAdapter,
      readyState: newAdapter.readyState
    }));
  });
  const setWallet = (newWallet) => {
    var _a, _b, _c;
    wallet.value = newWallet;
    readyState.value = (_a = newWallet == null ? void 0 : newWallet.readyState) != null ? _a : WalletReadyState.NotDetected;
    publicKey.value = (_b = newWallet == null ? void 0 : newWallet.adapter.publicKey) != null ? _b : null;
    connected.value = (_c = newWallet == null ? void 0 : newWallet.adapter.connected) != null ? _c : false;
  };
  watchEffect(() => {
    const foundWallet = name.value && wallets.value.find(({ adapter }) => adapter.name === name.value);
    setWallet(foundWallet != null ? foundWallet : null);
  });
  watchEffect((onInvalidate) => {
    const handler = () => unloadingWindow.value = true;
    window.addEventListener("beforeunload", handler);
    onInvalidate(() => window.removeEventListener("beforeunload", handler));
  });
  watchEffect((onInvalidate) => {
    function handleReadyStateChange(readyState2) {
      const prevWallets = wallets.value;
      const index2 = prevWallets.findIndex(({ adapter }) => adapter === this);
      if (index2 === -1)
        return;
      wallets.value = [
        ...prevWallets.slice(0, index2),
        { adapter: this, readyState: readyState2 },
        ...prevWallets.slice(index2 + 1)
      ];
    }
    wallets.value.forEach(
      ({ adapter }) => adapter.on("readyStateChange", handleReadyStateChange, adapter)
    );
    onInvalidate(
      () => wallets.value.forEach(
        ({ adapter }) => adapter.off("readyStateChange", handleReadyStateChange, adapter)
      )
    );
  });
  const select = async (walletName) => {
    if (name.value === walletName)
      return;
    name.value = walletName;
  };
  const handleConnect = () => setWallet(wallet.value);
  const handleDisconnect = () => {
    if (unloadingWindow.value)
      return;
    name.value = null;
  };
  const handleError = (error) => {
    if (!unloadingWindow.value)
      onError(error);
    return error;
  };
  watchEffect((onInvalidate) => {
    var _a;
    const adapter = (_a = wallet.value) == null ? void 0 : _a.adapter;
    if (!adapter)
      return;
    adapter.on("connect", handleConnect);
    adapter.on("disconnect", handleDisconnect);
    adapter.on("error", handleError);
    onInvalidate(() => {
      adapter.off("connect", handleConnect);
      adapter.off("disconnect", handleDisconnect);
      adapter.off("error", handleError);
    });
  });
  const connect = async () => {
    if (connected.value || connecting.value || disconnecting.value)
      return;
    if (!wallet.value)
      throw handleError(new WalletNotSelectedError());
    const adapter = wallet.value.adapter;
    if (!ready.value) {
      name.value = null;
      if (typeof window !== "undefined") {
        window.open(adapter.url, "_blank");
      }
      throw handleError(new WalletNotReadyError());
    }
    try {
      connecting.value = true;
      await adapter.connect();
    } catch (error) {
      name.value = null;
      throw error;
    } finally {
      connecting.value = false;
    }
  };
  const disconnect = async () => {
    if (disconnecting.value)
      return;
    if (!wallet.value) {
      name.value = null;
      return;
    }
    try {
      disconnecting.value = true;
      await wallet.value.adapter.disconnect();
    } catch (error) {
      name.value = null;
      throw error;
    } finally {
      disconnecting.value = false;
    }
  };
  const sendTransaction = async (transaction, connection, options) => {
    var _a;
    const adapter = (_a = wallet.value) == null ? void 0 : _a.adapter;
    if (!adapter)
      throw handleError(new WalletNotSelectedError());
    if (!connected.value)
      throw handleError(new WalletNotConnectedError());
    return await adapter.sendTransaction(transaction, connection, options);
  };
  const signTransaction = computed(() => {
    var _a;
    const adapter = (_a = wallet.value) == null ? void 0 : _a.adapter;
    if (!(adapter && "signTransaction" in adapter))
      return;
    return async (transaction) => {
      if (!connected.value)
        throw handleError(new WalletNotConnectedError());
      return await adapter.signTransaction(transaction);
    };
  });
  const signAllTransactions = computed(() => {
    var _a;
    const adapter = (_a = wallet.value) == null ? void 0 : _a.adapter;
    if (!(adapter && "signAllTransactions" in adapter))
      return;
    return async (transactions) => {
      if (!connected.value)
        throw handleError(new WalletNotConnectedError());
      return await adapter.signAllTransactions(transactions);
    };
  });
  const signMessage = computed(() => {
    var _a;
    const adapter = (_a = wallet.value) == null ? void 0 : _a.adapter;
    if (!(adapter && "signMessage" in adapter))
      return;
    return async (message) => {
      if (!connected.value)
        throw handleError(new WalletNotConnectedError());
      return await adapter.signMessage(message);
    };
  });
  watchEffect(async () => {
    if (!autoConnect.value || !wallet.value || !ready.value || connected.value || connecting.value) {
      return;
    }
    try {
      connecting.value = true;
      await wallet.value.adapter.connect();
    } catch (error) {
      name.value = null;
    } finally {
      connecting.value = false;
    }
  });
  return {
    wallets,
    autoConnect,
    wallet,
    publicKey,
    readyState,
    ready,
    connected,
    connecting,
    disconnecting,
    select,
    connect,
    disconnect,
    sendTransaction,
    signTransaction,
    signAllTransactions,
    signMessage
  };
};
let walletStore = null;
const useWallet = () => {
  if (walletStore)
    return walletStore;
  throw new WalletNotInitializedError(
    "Wallet not initialized. Please use the `initWallet` method to initialize the wallet."
  );
};
const initWallet = (walletStoreProps) => {
  walletStore = createWalletStore(walletStoreProps);
};
const _sfc_main$4 = defineComponent({
  props: {
    wallet: Object
  },
  setup(props) {
    return toRefs(props);
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$4 = { class: "swv-button-icon" };
const _hoisted_2$4 = ["src", "alt"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("i", _hoisted_1$4, [
    _ctx.wallet ? (openBlock(), createElementBlock("img", {
      key: 0,
      src: _ctx.wallet.adapter.icon,
      alt: `${_ctx.wallet.adapter.name} icon`
    }, null, 8, _hoisted_2$4)) : createCommentVNode("", true)
  ]);
}
const WalletIcon = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const _sfc_main$3 = defineComponent({
  components: {
    WalletIcon
  },
  props: {
    disabled: Boolean
  },
  setup(props, { emit }) {
    const { disabled } = toRefs(props);
    const { wallet, connect, connecting, connected } = useWallet();
    const content = computed(() => {
      if (connecting.value)
        return "Connecting ...";
      if (connected.value)
        return "Connected";
      if (wallet.value)
        return "Connect";
      return "Connect Wallet";
    });
    const onClick = (event) => {
      emit("click", event);
      if (event.defaultPrevented)
        return;
      connect().catch(() => {
      });
    };
    const scope = {
      wallet,
      disabled,
      connecting,
      connected,
      content,
      onClick
    };
    return {
      scope,
      ...scope
    };
  }
});
const _hoisted_1$3 = ["disabled"];
const _hoisted_2$3 = ["textContent"];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_wallet_icon = resolveComponent("wallet-icon");
  return renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.scope)), () => [
    createElementVNode("button", {
      class: "swv-button swv-button-trigger",
      disabled: _ctx.disabled || !_ctx.wallet || _ctx.connecting || _ctx.connected,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }, [
      _ctx.wallet ? (openBlock(), createBlock(_component_wallet_icon, {
        key: 0,
        wallet: _ctx.wallet
      }, null, 8, ["wallet"])) : createCommentVNode("", true),
      createElementVNode("p", {
        textContent: toDisplayString(_ctx.content)
      }, null, 8, _hoisted_2$3)
    ], 8, _hoisted_1$3)
  ]);
}
const WalletConnectButton = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const _sfc_main$2 = defineComponent({
  components: {
    WalletIcon
  },
  props: {
    disabled: Boolean
  },
  setup(props, { emit }) {
    const { disabled } = toRefs(props);
    const { wallet, disconnect, disconnecting } = useWallet();
    const content = computed(() => {
      if (disconnecting.value)
        return "Disconnecting ...";
      if (wallet.value)
        return "Disconnect";
      return "Disconnect Wallet";
    });
    const handleClick = (event) => {
      emit("click", event);
      if (event.defaultPrevented)
        return;
      disconnect().catch(() => {
      });
    };
    const scope = {
      wallet,
      disconnecting,
      disabled,
      content,
      handleClick
    };
    return {
      scope,
      ...scope
    };
  }
});
const _hoisted_1$2 = ["disabled"];
const _hoisted_2$2 = ["textContent"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_wallet_icon = resolveComponent("wallet-icon");
  return renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.scope)), () => [
    createElementVNode("button", {
      class: "swv-button swv-button-trigger",
      disabled: _ctx.disabled || _ctx.disconnecting || !_ctx.wallet,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.wallet ? (openBlock(), createBlock(_component_wallet_icon, {
        key: 0,
        wallet: _ctx.wallet
      }, null, 8, ["wallet"])) : createCommentVNode("", true),
      createElementVNode("p", {
        textContent: toDisplayString(_ctx.content)
      }, null, 8, _hoisted_2$2)
    ], 8, _hoisted_1$2)
  ]);
}
const WalletDisconnectButton = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1 = defineComponent({
  components: {
    WalletIcon
  },
  props: {
    featured: { type: Number, default: 3 },
    container: { type: String, default: "body" },
    logo: String,
    dark: Boolean
  },
  setup(props, { slots }) {
    const { featured, container, logo, dark } = toRefs(props);
    const modalPanel = ref(null);
    const modalOpened = ref(false);
    const openModal = () => modalOpened.value = true;
    const closeModal = () => modalOpened.value = false;
    const hasLogo = computed(() => !!slots.logo || !!logo.value);
    const { wallets, select: selectWallet } = useWallet();
    const orderedWallets = computed(() => {
      const installed = [];
      const notDetected = [];
      const loadable = [];
      wallets.value.forEach((wallet) => {
        if (wallet.readyState === WalletReadyState.NotDetected) {
          notDetected.push(wallet);
        } else if (wallet.readyState === WalletReadyState.Loadable) {
          loadable.push(wallet);
        } else if (wallet.readyState === WalletReadyState.Installed) {
          installed.push(wallet);
        }
      });
      return [...installed, ...loadable, ...notDetected];
    });
    const expandedWallets = ref(false);
    const featuredWallets = computed(
      () => orderedWallets.value.slice(0, featured.value)
    );
    const hiddenWallets = computed(
      () => orderedWallets.value.slice(featured.value)
    );
    const walletsToDisplay = computed(
      () => expandedWallets.value ? wallets.value : featuredWallets.value
    );
    onClickOutside(modalPanel, closeModal);
    onKeyStroke("Escape", closeModal);
    onKeyStroke("Tab", (event) => {
      var _a, _b;
      const focusableElements = (_b = (_a = modalPanel.value) == null ? void 0 : _a.querySelectorAll("button")) != null ? _b : [];
      const firstElement = focusableElements == null ? void 0 : focusableElements[0];
      const lastElement = focusableElements == null ? void 0 : focusableElements[focusableElements.length - 1];
      if (event.shiftKey && document.activeElement === firstElement && lastElement) {
        lastElement.focus();
        event.preventDefault();
      } else if (!event.shiftKey && document.activeElement === lastElement && firstElement) {
        firstElement.focus();
        event.preventDefault();
      }
    });
    watch(modalOpened, (isOpened) => {
      if (!isOpened)
        return;
      nextTick(
        () => {
          var _a, _b, _c;
          return (_c = (_b = (_a = modalPanel.value) == null ? void 0 : _a.querySelectorAll("button")) == null ? void 0 : _b[0]) == null ? void 0 : _c.focus();
        }
      );
    });
    const scrollLock = useScrollLock(document.body);
    watch(modalOpened, (isOpened) => scrollLock.value = isOpened);
    const scope = {
      dark,
      logo,
      hasLogo,
      featured,
      container,
      modalPanel,
      modalOpened,
      openModal,
      closeModal,
      expandedWallets,
      walletsToDisplay,
      featuredWallets,
      hiddenWallets,
      selectWallet
    };
    return {
      scope,
      ...scope
    };
  }
});
const _hoisted_1$1 = /* @__PURE__ */ createElementVNode("div", { class: "swv-modal-overlay" }, null, -1);
const _hoisted_2$1 = {
  class: "swv-modal-container",
  ref: "modalPanel"
};
const _hoisted_3$1 = {
  key: 0,
  class: "swv-modal-logo-wrapper"
};
const _hoisted_4$1 = ["src"];
const _hoisted_5$1 = /* @__PURE__ */ createElementVNode("h1", {
  class: "swv-modal-title",
  id: "swv-modal-title"
}, "Connect Wallet", -1);
const _hoisted_6 = /* @__PURE__ */ createElementVNode("svg", {
  width: "14",
  height: "14"
}, [
  /* @__PURE__ */ createElementVNode("path", { d: "M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z" })
], -1);
const _hoisted_7 = [
  _hoisted_6
];
const _hoisted_8 = { class: "swv-modal-list" };
const _hoisted_9 = ["onClick"];
const _hoisted_10 = { class: "swv-button" };
const _hoisted_11 = ["textContent"];
const _hoisted_12 = {
  key: 0,
  class: "swv-wallet-status"
};
const _hoisted_13 = ["aria-expanded"];
const _hoisted_14 = /* @__PURE__ */ createElementVNode("i", { class: "swv-button-icon" }, [
  /* @__PURE__ */ createElementVNode("svg", {
    width: "11",
    height: "6",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createElementVNode("path", { d: "m5.938 5.73 4.28-4.126a.915.915 0 0 0 0-1.322 1 1 0 0 0-1.371 0L5.253 3.736 1.659.272a1 1 0 0 0-1.371 0A.93.93 0 0 0 0 .932c0 .246.1.48.288.662l4.28 4.125a.99.99 0 0 0 1.37.01z" })
  ])
], -1);
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_wallet_icon = resolveComponent("wallet-icon");
  return openBlock(), createElementBlock(Fragment, null, [
    createElementVNode("div", {
      class: normalizeClass(_ctx.dark ? "swv-dark" : "")
    }, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.scope)))
    ], 2),
    _ctx.modalOpened ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: _ctx.container
    }, [
      createElementVNode("div", {
        "aria-labelledby": "swv-modal-title",
        "aria-modal": "true",
        class: normalizeClass(["swv-modal", _ctx.dark ? "swv-dark" : ""]),
        role: "dialog"
      }, [
        renderSlot(_ctx.$slots, "overlay", normalizeProps(guardReactiveProps(_ctx.scope)), () => [
          _hoisted_1$1
        ]),
        createElementVNode("div", _hoisted_2$1, [
          renderSlot(_ctx.$slots, "modal", normalizeProps(guardReactiveProps(_ctx.scope)), () => [
            createElementVNode("div", {
              class: normalizeClass(["swv-modal-wrapper", { "swv-modal-wrapper-no-logo": !_ctx.hasLogo }])
            }, [
              _ctx.hasLogo ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
                renderSlot(_ctx.$slots, "logo", normalizeProps(guardReactiveProps(_ctx.scope)), () => [
                  createElementVNode("img", {
                    alt: "logo",
                    class: "swv-modal-logo",
                    src: _ctx.logo
                  }, null, 8, _hoisted_4$1)
                ])
              ])) : createCommentVNode("", true),
              _hoisted_5$1,
              createElementVNode("button", {
                onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.closeModal && _ctx.closeModal(...args), ["prevent"])),
                class: "swv-modal-button-close"
              }, _hoisted_7),
              createElementVNode("ul", _hoisted_8, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.walletsToDisplay, (wallet) => {
                  return openBlock(), createElementBlock("li", {
                    key: wallet.adapter.name,
                    onClick: ($event) => {
                      _ctx.selectWallet(wallet.adapter.name);
                      _ctx.closeModal();
                    }
                  }, [
                    createElementVNode("button", _hoisted_10, [
                      createVNode(_component_wallet_icon, { wallet }, null, 8, ["wallet"]),
                      createElementVNode("p", {
                        textContent: toDisplayString(wallet.adapter.name)
                      }, null, 8, _hoisted_11),
                      wallet.readyState === "Installed" ? (openBlock(), createElementBlock("div", _hoisted_12, " Detected ")) : createCommentVNode("", true)
                    ])
                  ], 8, _hoisted_9);
                }), 128))
              ]),
              _ctx.hiddenWallets.length > 0 ? (openBlock(), createElementBlock("button", {
                key: 1,
                "aria-controls": "swv-modal-collapse",
                "aria-expanded": _ctx.expandedWallets,
                class: normalizeClass(["swv-button swv-modal-collapse-button", { "swv-modal-collapse-button-active": _ctx.expandedWallets }]),
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.expandedWallets = !_ctx.expandedWallets)
              }, [
                createTextVNode(toDisplayString(_ctx.expandedWallets ? "Less" : "More") + " options ", 1),
                _hoisted_14
              ], 10, _hoisted_13)) : createCommentVNode("", true)
            ], 2)
          ])
        ], 512)
      ], 2)
    ], 8, ["to"])) : createCommentVNode("", true)
  ], 64);
}
const WalletModalProvider = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const _sfc_main = defineComponent({
  components: {
    WalletConnectButton,
    WalletIcon,
    WalletModalProvider
  },
  props: {
    featured: { type: Number, default: 3 },
    container: { type: String, default: "body" },
    logo: String,
    dark: Boolean
  },
  setup(props) {
    const { featured, container, logo, dark } = toRefs(props);
    const { publicKey, wallet, disconnect } = useWallet();
    const dropdownPanel = ref();
    const dropdownOpened = ref(false);
    const openDropdown = () => {
      dropdownOpened.value = true;
    };
    const closeDropdown = () => {
      dropdownOpened.value = false;
    };
    onClickOutside(dropdownPanel, closeDropdown);
    const publicKeyBase58 = computed(() => {
      var _a;
      return (_a = publicKey.value) == null ? void 0 : _a.toBase58();
    });
    const publicKeyTrimmed = computed(() => {
      if (!wallet.value || !publicKeyBase58.value)
        return null;
      return publicKeyBase58.value.slice(0, 4) + ".." + publicKeyBase58.value.slice(-4);
    });
    const {
      copy,
      copied: addressCopied,
      isSupported: canCopy
    } = useClipboard();
    const copyAddress = () => publicKeyBase58.value && copy(publicKeyBase58.value);
    const scope = {
      featured,
      container,
      logo,
      dark,
      wallet,
      publicKey,
      publicKeyTrimmed,
      publicKeyBase58,
      canCopy,
      addressCopied,
      dropdownPanel,
      dropdownOpened,
      openDropdown,
      closeDropdown,
      copyAddress,
      disconnect
    };
    return {
      scope,
      ...scope
    };
  }
});
const _hoisted_1 = ["onClick"];
const _hoisted_2 = {
  key: 2,
  class: "swv-dropdown"
};
const _hoisted_3 = ["aria-expanded", "title"];
const _hoisted_4 = ["textContent"];
const _hoisted_5 = ["onClick"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_wallet_connect_button = resolveComponent("wallet-connect-button");
  const _component_wallet_icon = resolveComponent("wallet-icon");
  const _component_wallet_modal_provider = resolveComponent("wallet-modal-provider");
  return openBlock(), createBlock(_component_wallet_modal_provider, {
    featured: _ctx.featured,
    container: _ctx.container,
    logo: _ctx.logo,
    dark: _ctx.dark
  }, {
    default: withCtx((modalScope) => [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ ...modalScope, ..._ctx.scope })), () => [
        !_ctx.wallet ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: "swv-button swv-button-trigger",
          onClick: modalScope.openModal
        }, " Select Wallet ", 8, _hoisted_1)) : !_ctx.publicKeyBase58 ? (openBlock(), createBlock(_component_wallet_connect_button, { key: 1 })) : (openBlock(), createElementBlock("div", _hoisted_2, [
          renderSlot(_ctx.$slots, "dropdown-button", normalizeProps(guardReactiveProps({ ...modalScope, ..._ctx.scope })), () => [
            createElementVNode("button", {
              class: "swv-button swv-button-trigger",
              style: normalizeStyle({ pointerEvents: _ctx.dropdownOpened ? "none" : "auto" }),
              "aria-expanded": _ctx.dropdownOpened,
              title: _ctx.publicKeyBase58,
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.openDropdown && _ctx.openDropdown(...args))
            }, [
              createVNode(_component_wallet_icon, { wallet: _ctx.wallet }, null, 8, ["wallet"]),
              createElementVNode("p", {
                textContent: toDisplayString(_ctx.publicKeyTrimmed)
              }, null, 8, _hoisted_4)
            ], 12, _hoisted_3)
          ]),
          renderSlot(_ctx.$slots, "dropdown", normalizeProps(guardReactiveProps({ ...modalScope, ..._ctx.scope })), () => [
            createElementVNode("ul", {
              "aria-label": "dropdown-list",
              class: normalizeClass(["swv-dropdown-list", { "swv-dropdown-list-active": _ctx.dropdownOpened }]),
              ref: "dropdownPanel",
              role: "menu"
            }, [
              renderSlot(_ctx.$slots, "dropdown-list", normalizeProps(guardReactiveProps({ ...modalScope, ..._ctx.scope })), () => [
                _ctx.canCopy ? (openBlock(), createElementBlock("li", {
                  key: 0,
                  onClick: _cache[1] || (_cache[1] = (...args) => _ctx.copyAddress && _ctx.copyAddress(...args)),
                  class: "swv-dropdown-list-item",
                  role: "menuitem"
                }, toDisplayString(_ctx.addressCopied ? "Copied" : "Copy address"), 1)) : createCommentVNode("", true),
                createElementVNode("li", {
                  onClick: ($event) => {
                    modalScope.openModal();
                    _ctx.closeDropdown();
                  },
                  class: "swv-dropdown-list-item",
                  role: "menuitem"
                }, " Change wallet ", 8, _hoisted_5),
                createElementVNode("li", {
                  onClick: _cache[2] || (_cache[2] = ($event) => {
                    _ctx.disconnect();
                    _ctx.closeDropdown();
                  }),
                  class: "swv-dropdown-list-item",
                  role: "menuitem"
                }, " Disconnect ")
              ])
            ], 2)
          ])
        ]))
      ])
    ]),
    overlay: withCtx((modalScope) => [
      renderSlot(_ctx.$slots, "modal-overlay", normalizeProps(guardReactiveProps({ ...modalScope, ..._ctx.scope })))
    ]),
    modal: withCtx((modalScope) => [
      renderSlot(_ctx.$slots, "modal", normalizeProps(guardReactiveProps({ ...modalScope, ..._ctx.scope })))
    ]),
    _: 3
  }, 8, ["featured", "container", "logo", "dark"]);
}
const WalletMultiButton = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
function useAnchorWallet() {
  const walletStore2 = useWallet();
  return computed(() => {
    if (!walletStore2)
      return;
    const { signTransaction, signAllTransactions, publicKey } = walletStore2;
    if (!publicKey.value || !signTransaction.value || !signAllTransactions.value)
      return;
    return {
      publicKey: publicKey.value,
      signTransaction: signTransaction.value,
      signAllTransactions: signAllTransactions.value
    };
  });
}
const index = {
  install: (app, options = {}) => {
    initWallet(options);
    app.config.globalProperties.$wallet = useWallet();
  }
};
export {
  WalletConnectButton,
  WalletDisconnectButton,
  WalletIcon,
  WalletModalProvider,
  WalletMultiButton,
  WalletNotInitializedError,
  WalletNotSelectedError,
  createWalletStore,
  index as default,
  initWallet,
  useAnchorWallet,
  useWallet
};
//# sourceMappingURL=solana-wallets-vue.mjs.map
